<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Ionic.Utils.Zip</name>
    </assembly>
    <members>
        <member name="T:Ionic.Utils.Zip.SelfExtractorFlavor">
            <summary>
            An enum that provides the different self-extractor flavors
            </summary>
        </member>
        <member name="F:Ionic.Utils.Zip.SelfExtractorFlavor.ConsoleApplication">
            <summary>
            A self-extracting zip archive that runs from the console or command line. 
            </summary>
        </member>
        <member name="F:Ionic.Utils.Zip.SelfExtractorFlavor.WinFormsApplication">
            <summary>
            A self-extracting zip archive that presents a graphical user interface when it is executed.. 
            </summary>
        </member>
        <member name="T:Ionic.Utils.Zip.ZipFile">
            <summary>
            The ZipFile type represents a zip archive file.  This is the main type in the 
            DotNetZip class library.  This class reads and writes zip files, as defined in the format
            for zip described by PKWare.  The compression for this implementation is based on the
            System.IO.Compression.DeflateStream base class in the .NET Framework
            base class library, for v2.0 and later.
            </summary>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.SaveSelfExtractor(System.String,Ionic.Utils.Zip.SelfExtractorFlavor)">
            <summary>
            Saves the ZipFile instance to a self-extracting zip archive.
            </summary>
            
            <remarks>
            
            <para>
            The generated exe image will execute on any machine that has the .NET Framework 2.0
            installed on it.
            </para>
            
            <para>
            There are two "flavors" of self-extracting archive.  The <c>WinFormsApplication</c>
            version will pop up a GUI and allow the user to select a target directory into which
            to extract. There's also a checkbox allowing the user to specify to overwrite
            existing files, and another checkbox to allow the user to request that Explorer be
            opened to see the extracted files after extraction.  The other flavor is
            <c>ConsoleApplication</c>.  A self-extractor generated with that flavor setting will
            run from the command line. It accepts command-line options to set the overwrite
            behavior, and to specify the target extraction directory.
            
            </para>
            <para>
            There are a few temporary files created during the saving to a self-extracting zip. 
            These files are normally stored in the directory pointed to by the TEMP environment
            variable, and they are removed upon successful completion of this method. 
            </para>
            </remarks>
            
            <example>
            <code>
            string DirectoryPath = "c:\\Documents\\Project7";
            using (ZipFile zip = new ZipFile())
            {
                zip.AddDirectory(DirectoryPath, System.IO.Path.GetFileName(DirectoryPath));
                zip.Comment = "This will be embedded into a self-extracting console-based exe";
                zip.SaveSelfExtractor("archive.exe", SelfExtractorFlavor.ConsoleApplication);
            }
            </code>
            <code lang="VB">
            Dim DirectoryPath As String = "c:\Documents\Project7"
            Using zip As New ZipFile()
                zip.AddDirectory(DirectoryPath, System.IO.Path.GetFileName(DirectoryPath))
                zip.Comment = "This will be embedded into a self-extracting console-based exe"
                zip.SaveSelfExtractor("archive.exe", SelfExtractorFlavor.ConsoleApplication)
            End Using
            </code>
            </example>
            
            <param name="exeToGenerate">a pathname, possibly fully qualified, to be created. Typically it will end in an .exe extension.</param>
            <param name="flavor">Indicates whether a Winforms or Console self-extractor is desired.</param>
        </member>
        <member name="F:Ionic.Utils.Zip.ZipFile.DefaultEncoding">
            <summary>
            The default text encoding used in zip archives.  It is numeric 437, also known as IBM437. 
            </summary>
            <seealso cref="P:Ionic.Utils.Zip.ZipFile.Encoding">Encoding</seealso>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.#ctor(System.String)">
             <summary>
             Creates a new ZipFile instance, using the specified ZipFileName for the filename. 
             The ZipFileName may be fully qualified.
             </summary>
             
             <remarks>
             <para>
             Applications can use this constructor to create a new ZipFile for writing, 
             or to slurp in an existing zip archive for read and write purposes.  
             </para>
             
             <para>
             To create a new zip archive, an application should call this constructor,
             passing the name of a file that does not exist.  Then the application can
             add directories or files to the ZipFile via <c>AddDirectory()</c>,
             <c>AddFile()</c>, <c>AddItem()</c> and then write the zip archive to the
             disk by calling <c>Save()</c>. The zip file is not actually written to
             the disk until the application calls <c>ZipFile.Save()</c>.  At that point
             the new zip file with the given name is created. 
             </para>
             
             <para>
             To read an existing zip archive, the application should call this constructor,
             passing the name of a valid zip file that does exist.  The file is then read into
             the <c>ZipFile</c> instance.  The app can then enumerate the entries or can modify
             the zip file, for example adding entries, removing entries, changing comments, and
             so on.  When reading an existing zip archive, the application may wish to
             explicitly specify that it is reading an existing zip file by using
             <c>ZipFile.Read()</c>.  On the other hand, this parameterized constructor allows
             applications to use the same code to add items to a zip archive, regardless of
             whether the zip file exists.
             </para>
             
             <para>
             To encrypt the data for the  files added to the ZipFile instance, set the Password
             property after creating the ZipFile instance.
             </para>
             
             </remarks>
            
             <exception cref="T:Ionic.Utils.Zip.ZipException">
             Thrown if zipFileName refers to an existing file that is not a valid zip file. 
             </exception>
            
             <example>
             This example shows how to create a zipfile, and add a few files into it. 
             <code>
             using (ZipFile zip = new ZipFile(args[0]))
             { 
               // Store all files found in the top level directory, into the zip archive.
               String[] filenames = System.IO.Directory.GetFiles(args[1]);
               foreach (String filename in filenames)
               {
                 Console.WriteLine("Adding {0}...", filename);
                 zip.AddFile(filename);
               }  
               zip.Save();
             }
             </code>
             
             <code lang="VB">
             Dim ZipToCreate As String = "ex1.zip"
             Dim DirectoryToZip As String = "c:\temp"
             Using zip As ZipFile = New ZipFile(ZipToCreate)
                 Dim filenames As String() = System.IO.Directory.GetFiles(DirectoryToZip)
                 Dim filename As String
                 For Each filename In filenames
                     Console.WriteLine("Adding {0}...", filename)
                     zip.AddFile(filename)
                 Next
                 zip.Save
             End Using
             </code>
             </example>
            
             <param name="zipFileName">The filename to use for the new zip archive.</param>
            
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.#ctor">
             <summary>
             Create a zip file, without specifying a target filename or stream to save to. 
             </summary>
             
             <remarks>
             If you do eventually call <c>Save()</c>, you will need to have specified
             a zip filename at some point. Either as a parameter to <c>Save()</c> or 
             on the ZipFile object itself.
             </remarks>
             
             <example>
             This example creates a Zip archive called Backup.zip, containing all the files
             in the directory DirectoryToZip. Files within subdirectories are not zipped up.
             <code>
             using (ZipFile zip = new ZipFile())
             { 
               // Store all files found in the top level directory, into the zip archive.
               // note: this code does not recurse subdirectories!
               String[] filenames = System.IO.Directory.GetFiles(DirectoryToZip);
               foreach (String filename in filenames)
               {
                 Console.WriteLine("Adding {0}...", filename);
                 zip.AddFile(filename);
               }  
               zip.Save("Backup.zip");
             }
             </code>
            
             <code lang="VB">
             Using zip As New ZipFile
                 ' Store all files found in the top level directory, into the zip archive.
                 ' note: this code does not recurse subdirectories!
                 Dim filenames As String() = System.IO.Directory.GetFiles(DirectoryToZip)
                 Dim filename As String
                 For Each filename In filenames
                     Console.WriteLine("Adding {0}...", filename)
                     zip.AddFile(filename)
                 Next
                 zip.Save("Backup.zip")
             End Using
             </code>
             </example>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.#ctor(System.String,System.IO.TextWriter)">
             <summary>
             Creates a new ZipFile instance, using the specified ZipFileName for the filename. 
             The ZipFileName may be fully qualified.
             </summary>
            
             <remarks>
             <para>
             Applications can use this constructor to create a new ZipFile for writing, 
             or to slurp in an existing zip archive for read and write purposes.  
             </para>
            
             <para>
             To create a new zip archive, an application should call this constructor,
             passing the name of a file that does not exist.  Then the application can
             add directories or files to the ZipFile via <c>AddDirectory()</c>,
             <c>AddFile()</c>, <c>AddItem()</c> and then write the zip archive to the
             disk by calling <c>Save()</c>. The zip file is not actually written to
             the disk until the application calls <c>ZipFile.Save()</c>.  At that point
             the new zip file with the given name is created. 
             </para>
             
             <para>
             To read an existing zip archive, the application should call this constructor,
             passing the name of a valid zip file that does exist.  The file is then read into
             the <c>ZipFile</c> instance.  The app can then enumerate the entries or can modify
             the zip file, for example adding entries, removing entries, changing comments, and
             so on.  When reading an existing zip archive, the application may wish to
             explicitly specify that it is reading an existing zip file by using
             <c>ZipFile.Read()</c>.  On the other hand, this parameterized constructor allows
             applications to use the same code to add items to a zip archive, regardless of
             whether the zip file exists.
             </para>
            
             <para>
             This version of the constructor allows the caller to pass in a TextWriter, to which
             verbose messages will be written during extraction or creation of the zip archive.
             A console application may wish to pass System.Console.Out to get messages on the
             Console. A graphical or headless application may wish to capture the messages in a
             different <c>TextWriter</c>, for example, a <c>StringWriter</c>.
             </para>
             
             <para>
             To encrypt the data for the  files added to the ZipFile instance, set the Password
             property after creating the ZipFile instance.
             </para>
             
             </remarks>
            
             <exception cref="T:Ionic.Utils.Zip.ZipException">
             Thrown if zipFileName refers to an existing file that is not a valid zip file. 
             </exception>
            
             <example>
             <code>
             using (ZipFile zip = new ZipFile("Backup.zip", System.Console.Out))
             { 
               // Store all files found in the top level directory, into the zip archive.
               // note: this code does not recurse subdirectories!
               String[] filenames = System.IO.Directory.GetFiles(DirectoryToZip);
               foreach (String filename in filenames)
               {
                 Console.WriteLine("Adding {0}...", filename);
                 zip.AddFile(filename);
               }  
               zip.Save();
             }
             </code>
            
             <code lang="VB">
             Using zip As New ZipFile("Backup.zip", System.Console.Out)
                 ' Store all files found in the top level directory, into the zip archive.
                 ' note: this code does not recurse subdirectories!
                 Dim filenames As String() = System.IO.Directory.GetFiles(DirectoryToZip)
                 Dim filename As String
                 For Each filename In filenames
                     Console.WriteLine("Adding {0}...", filename)
                     zip.AddFile(filename)
                 Next
                 zip.Save
             End Using
             </code>
             </example>
             
             <param name="zipFileName">The filename to use for the new zip archive.</param>
             <param name="statusMessageWriter">A TextWriter to use for writing verbose status messages.</param>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.#ctor(System.IO.Stream)">
             <summary>
             Constructor to create an instance of ZipFile that writes Zip archives to a <c>System.IO.Stream</c>.
             </summary>
             
             <remarks>
             
             <para>
             Applications can use this constructor to create an instance of ZipFile 
             for writing to a stream. This is useful when zipping up content, but for any 
             reason it is not desirable to create a zip file in the filesystem itself. 
             </para>
            
             <para>
             Typically an application writing a zip archive in this manner will create and
             open a stream, then call this constructor, passing in the stream.  Then the app will add 
             directories or files to the ZipFile via <c>AddDirectory</c> or <c>AddFile</c> or <c>AddItem</c>.  The app
             will then write the zip archive to the memory stream by calling <c>Save()</c>. 
             </para>
            
             <para>
             The compressed (zipped) data is not actually written to the stream until the
             application calls <c>ZipFile.Save</c>.  This means the file data must be
             available at the time the <c>Save</c> method is invoked. 
             </para>
            
             <para>
             When using a filesystem file for the Zip output, it is possible to call
             <c>Save</c> multiple times on the ZipFile instance. With each call the zip content
             is written to the output file. When saving to a <c>Stream</c>, as you would do when you use this constructor, after the initial
             call to <c>Save</c>, additional calls to <c>Save</c> will throw. This is because the
             stream is assumed to be a write-only stream, and after the initial <c>Save</c>, it
             is not possible to seek backwards and "unwrite" the zip file data.
             </para>
            
             <para>
             Calling Save() on a ZipFile that has been created with this constructor will not
             result in the creation of a temporary zipfile in the filesystem.  
             </para>
            
             </remarks>
             
             <exception cref="T:System.ArgumentException">
             Thrown if the stream is not writable.  Seriously, think about it, dude. 
             You need a writable stream if you're going to extract zip content to it. 
             </exception>
            
             <example>
             <code>
                byte[] buffer= new byte[100000]; // 100k max
                System.IO.MemoryStream ms= new System.IO.MemoryStream(buffer);
            
                // write to the memory stream:
                try
                {
                  using (ZipFile zip = new ZipFile(ms,System.Console.Out))
                  {
                    zip.Comment= "This is the comment attached to the archive.";
                    zip.AddItem(directoryName);  // and recurse
                    zip.Save(); // write all the data to the stream and close it
                  }
                }
                catch (System.Exception ex1)
                {
                  System.Console.Error.WriteLine("exception: " + ex1);
                }
             </code>
             <code lang="VB">
               Dim buffer As Byte() = New Byte(100000) {}
               Dim ms As New System.IO.MemoryStream(buffer)
               ' write to the memory stream:
               Try 
                   Using zip As ZipFile = New ZipFile(ms, Console.Out)
                       zip.Comment = "This is the comment attached to the archive."
                       ' Add directory and recurse
                       zip.AddItem(NameOfDirectoryToZip)
                       ' now, write all the data to the stream and close it:
                       zip.Save
                   End Using
               Catch ex1 As Exception
                   Console.Error.WriteLine("exception: {0}", ex1.ToString())
               End Try
             </code>
             </example>
            
             <param name="outputStream">The <c>System.IO.Stream</c> to write to. It must be writable.</param>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.#ctor(System.IO.Stream,System.IO.TextWriter)">
             <summary>
             Constructor to create an instance of ZipFile that writes Zip archives to a stream.
             </summary>
             
             <remarks>
             <para>Applications can use this constructor to create an instance of ZipFile 
             for writing to a stream. This is useful when zipping up content, but for any 
             reason it is not desirable to create a zip file in the filesystem itself. 
             </para>
             <para>Typically an application writing a zip archive in this manner will create and
             open a stream, then call this constructor, passing in the stream.  Then the app will 
             add directories or files to the ZipFile via AddDirectory or AddFile or AddItem.  The 
             app will then write the zip archive to the memory stream by calling <c>Save</c>. The 
             compressed (zipped) data is not actually written to the stream until the application 
             calls <c>ZipFile.Save</c> .
             </para>
             <para>
             This version of the constructor allows the caller to pass in a TextWriter, to which  
             verbose messages will be written during creation of the zip archive.  A console 
             application may wish to pass System.Console.Out to get messages on the Console. 
             A graphical or headless application may wish to capture the messages in a different 
             TextWriter. 
             </para>
             </remarks>
            
             <exception cref="T:System.ArgumentException">
             Thrown if the stream is not writable. 
             You need to specify a writable stream if you're going to extract zip content to it. 
             </exception>
            
             <param name="outputStream">The outputStream to write to. It must be writable.</param>
             <param name="statusMessageWriter">A TextWriter to use for writing verbose status messages.</param>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.AddItem(System.String)">
             <summary>
             Adds an item, either a file or a directory, to a zip file archive.  
             </summary>
             
             <remarks>
             <para>
             If adding a directory, the add is recursive on all files and subdirectories 
             contained within it. 
             </para>
             <para>
             The name of the item may be a relative path or a fully-qualified path.
             The item added by this call to the ZipFile is not written to the zip file
             archive until the application calls Save() on the ZipFile. 
             </para>
             <para>
             The directory name used for the file within the archive is the same as
             the directory name (potentially a relative path) specified in the FileOrDirectoryName.
             </para>
             </remarks>
            
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.AddFile(System.String)"/>
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.AddDirectory(System.String)"/>
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.UpdateItem(System.String)"/>
            
             <overloads>This method has two overloads.</overloads>
             <param name="fileOrDirectoryName">the name of the file or directory to add.</param>
             
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.AddItem(System.String,System.String)">
             <summary>
             Adds an item, either a file or a directory, to a zip file archive, 
             explicitly specifying the directory path to be used in the archive. 
             </summary>
             
             <remarks>
             <para>
             If adding a directory, the add is recursive on all files and subdirectories 
             contained within it. 
             </para>
             <para>
             The name of the item may be a relative path or a fully-qualified path.
             The item added by this call to the ZipFile is not written to the zip file
             archive until the application calls Save() on the ZipFile. 
             </para>
             
             <para>
             This version of the method allows the caller to explicitly specify the 
             directory path to be used in the archive, which would override the 
             "natural" path of the filesystem file.
             </para>
             
             <para>
             Encryption will be used on the file data if the Password
             has been set on the ZipFile object, prior to calling this method.
             </para>
             
             </remarks>
             
             <exception cref="T:System.IO.FileNotFoundException">
             Thrown if the file or directory passed in does not exist. 
             </exception>
            
             <param name="fileOrDirectoryName">the name of the file or directory to add.</param>
             <param name="directoryPathInArchive">
             The name of the directory path to use within the zip archive. 
             This path need not refer to an extant directory in the current filesystem.
             If the files within the zip are later extracted, this is the path used for the extracted file. 
             Passing null (nothing in VB)) will use the path on the FileOrDirectoryName.  Passing the empty string ("")
             will insert the item at the root path within the archive. 
             </param>
             
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.AddFile(System.String,System.String)"/>
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.AddDirectory(System.String,System.String)"/>
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.UpdateItem(System.String,System.String)"/>
            
             <example>
             This example shows how to zip up a set of files into a flat hierarchy, 
             regardless of where in the filesystem the files originated.
             <code>
             String[] itemnames= { 
               "c:\\temp\\Readme.txt",
               "MyProposal.docx",
               "SupportFiles",  // a directory
               "images\\Image1.jpg"
             };
            
             try
             {
               using (ZipFile zip = new ZipFile(ZipToCreate,System.Console.Out))
               {
                 for (int i = 1; i &lt; itemnames.Length; i++)
                 {
                   // will add Files or Dirs, recurses and flattens subdirectories
                   zip.AddItem(itemnames[i],"flat"); 
                 }
                 zip.Save();
               }
             }
             catch (System.Exception ex1)
             {
               System.Console.Error.WriteLine("exception: {0}", ex1);
             }
             </code>
            
             <code lang="VB">
               Dim itemnames As String() = _
                 New String() { "c:\temp\Readme.txt", _
                                "MyProposal.docx", _
                                "SupportFiles", _
                                "images\Image1.jpg" }
               Try 
                   Using zip As New ZipFile(ZipToCreate, Console.Out)
                       Dim i As Integer
                       For i = 1 To itemnames.Length - 1
                           ' will add Files or Dirs, recursing and flattening subdirectories.
                           zip.AddItem(itemnames(i), "flat")
                       Next i
                       zip.Save
                   End Using
               Catch ex1 As Exception
                   Console.Error.WriteLine("exception: {0}", ex1.ToString())
               End Try
             </code>
             </example>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.AddFile(System.String)">
             <summary>
             Adds a File to a Zip file archive. 
             </summary>
             <remarks>
             The file added by this call to the ZipFile is not written to the zip file
             archive until the application calls Save() on the ZipFile. 
             </remarks>
             
             <example>
             <para>
             In this example, three files are added to a Zip archive. The ReadMe.txt file
             will be placed in the root of the archive. The .png file will be placed in a folder 
             within the zip called photos\personal.  The pdf file will be included into a
             folder within the zip called Desktop.
             </para>
             <code>
                try
                {
                  using (ZipFile zip = new ZipFile("test2.zip",System.Console.Out))
                  {
                    zip.AddFile("c:\\photos\\personal\\7440-N49th.png");
                    zip.AddFile("c:\\Desktop\\2005_Annual_Report.pdf");
                    zip.AddFile("ReadMe.txt");
            
                    zip.Save();
                  }
                }
                catch (System.Exception ex1)
                {
                  System.Console.Error.WriteLine("exception: " + ex1);
                }
             </code>
             
             <code lang="VB">
              Try 
                   Using zip As ZipFile = New ZipFile("test2.zip", Console.Out)
                       zip.AddFile("c:\photos\personal\7440-N49th.png")
                       zip.AddFile("c:\Desktop\2005_Annual_Report.pdf")
                       zip.AddFile("ReadMe.txt")
                       zip.Save
                   End Using
               Catch ex1 As Exception
                   Console.Error.WriteLine("exception: {0}", ex1.ToString)
               End Try
             </code>
             </example>
             
             <overloads>This method has two overloads.</overloads>
             
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.AddItem(System.String)"/>
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.AddDirectory(System.String)"/>
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.UpdateFile(System.String)"/>
            
             <param name="fileName">
             The name of the file to add. It should refer to a file in the filesystem.  
             The name of the file may be a relative path or a fully-qualified path. 
             </param>
             <returns>The ZipEntry corresponding to the File added.</returns>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.AddFile(System.String,System.String)">
             <summary>
             Adds a File to a Zip file archive, potentially overriding the path to be used
             within the zip archive.
             </summary>
             
             <remarks>
             <para>
             The file added by this call to the ZipFile is not written to the zip file
             archive until the application calls Save() on the ZipFile. 
             </para>
             
             <para>
             This version of the method allows the caller to explicitly specify the 
             directory path to be used in the archive. 
             </para>
             
             </remarks>
             
             <example>
             <para>
             In this example, three files are added to a Zip archive. The ReadMe.txt file
             will be placed in the root of the archive. The .png file will be placed in a folder 
             within the zip called images.  The pdf file will be included into a
             folder within the zip called files\documents, and will be encrypted with the 
             given password.
             </para>
             <code>
             try
             {
               using (ZipFile zip = new ZipFile("Archive.zip",System.Console.Out))
               {
                 zip.AddFile("c:\\datafiles\\ReadMe.txt", "");
                 zip.AddFile("c:\\photos\\personal\\7440-N49th.png", "images");
                 zip.Password = "EncryptMe!";
                 zip.AddFile("c:\\Desktop\\2005_Annual_Report.pdf", "files\\documents");
                 zip.Save();
               }
             }
             catch (System.Exception ex1)
             {
               System.Console.Error.WriteLine("exception: {0}", ex1);
             }
             </code>
             
             <code lang="VB">
               Try 
                   Using zip As ZipFile = New ZipFile("Archive.zip", Console.Out)
                       zip.AddFile("c:\datafiles\ReadMe.txt", "")
                       zip.AddFile("c:\photos\personal\7440-N49th.png", "images")
                       zip.Password = "EncryptMe!"
                       zip.AddFile("c:\Desktop\2005_Annual_Report.pdf", "files\documents")
                       zip.Save
                   End Using
               Catch ex1 As Exception
                   Console.Error.WriteLine("exception: {0}", ex1)
               End Try
             </code>
             </example>
             
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.AddItem(System.String,System.String)"/>
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.AddDirectory(System.String,System.String)"/>
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.UpdateFile(System.String,System.String)"/>
            
             <param name="fileName">
             The name of the file to add.  The name of the file may be a relative path or 
             a fully-qualified path.
             </param>
            
             <param name="directoryPathInArchive">
             Specifies a directory path to use to override any path in the FileName.
             This path may, or may not, correspond to a real directory in the current filesystem.
             If the files within the zip are later extracted, this is the path used for the extracted file. 
             Passing null (nothing in VB) will use the path on the FileName, if any.  Passing the empty string ("")
             will insert the item at the root path within the archive. 
             </param>
            
             <returns>The ZipEntry corresponding to the file added.</returns>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.UpdateFile(System.String)">
             <summary>
             Adds or Updates a File in a Zip file archive.
             </summary>
             
             <remarks>
             <para>
             This method adds a file to a zip archive, or, if the file already exists in the zip archive, 
             this method Updates the content of that given filename in the zip archive.
             </para>
            
             <para>
             Upon success, there is no way for the application to learn whether the file was added or updated. 
             </para>
            
             </remarks>
            
             <example>
             This example shows how to Update an existing entry in a zipfile. The first call to 
             UpdateFile adds the file to the newly-created zip archive.  The second 
             call to UpdateFile updates the content for that file in the zip archive.
             <code>
             using (ZipFile zip1 = new ZipFile())
             {
               // UpdateFile might more accurately be called "AddOrUpdateFile"
               zip1.UpdateFile("MyDocuments\\Readme.txt", "");
               zip1.UpdateFile("CustomerList.csv", "");
               zip1.Comment = "This zip archive has been created.";
               zip1.Save("Content.zip");
             }
             
             using (ZipFile zip2 = ZipFile.Read("Content.zip"))
             {
               zip2.UpdateFile("Updates\\Readme.txt", "");
               zip2.Comment = "This zip archive has been updated: The Readme.txt file has been changed.";
               zip2.Save();
             }
            
             </code>
             <code lang="VB">
               Using zip1 As New ZipFile
                   ' UpdateFile might more accurately be called "AddOrUpdateFile"
                   zip1.UpdateFile("MyDocuments\Readme.txt", "")
                   zip1.UpdateFile("CustomerList.csv", "")
                   zip1.Comment = "This zip archive has been created."
                   zip1.Save("Content.zip")
               End Using
            
               Using zip2 As ZipFile = ZipFile.Read("Content.zip")
                   zip2.UpdateFile("Updates\Readme.txt", "")
                   zip2.Comment = "This zip archive has been updated: The Readme.txt file has been changed."
                   zip2.Save
               End Using
             </code>
             </example>
            
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.AddFile(System.String)"/>
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.UpdateDirectory(System.String)"/>
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.UpdateItem(System.String)"/>
            
             <param name="fileName">
             The name of the file to add or update. It should refer to a file in the filesystem.  
             The name of the file may be a relative path or a fully-qualified path. 
             </param>
            
             <returns>The ZipEntry corresponding to the File that was added or updated.</returns>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.UpdateFile(System.String,System.String)">
             <summary>
             Adds or Updates a File in a Zip file archive.
             </summary>
             
             <remarks>
             <para>
             This method adds a file to a zip archive, or, if the file already exists in the zip archive, 
             this method Updates the content of that given filename in the zip archive.
             </para>
             
             <para>
             This version of the method allows the caller to explicitly specify the 
             directory path to be used in the archive.  The entry to be added or updated is found by 
             using the specified directory path, combined with the basename of the specified 
             filename. 
             </para>
             
             <para>
             Upon success, there is no way for the application to learn whether the file was added or updated. 
             </para>
             </remarks>
             
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.AddFile(System.String,System.String)"/>
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.UpdateDirectory(System.String,System.String)"/>
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.UpdateItem(System.String,System.String)"/>
            
             <param name="fileName">
             The name of the file to add or update. It should refer to a file in the filesystem.  
             The name of the file may be a relative path or a fully-qualified path. 
             </param>
            
             <param name="directoryPathInArchive">
             Specifies a directory path to use to override any path in the FileName.
             This path may, or may not, correspond to a real directory in the current filesystem.
             If the files within the zip are later extracted, this is the path used for the extracted file. 
             Passing null (nothing in VB) will use the path on the FileName, if any.  Passing the empty string ("")
             will insert the item at the root path within the archive. 
             </param>
            
             <returns>The ZipEntry corresponding to the File that was added or updated.</returns>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.UpdateDirectory(System.String)">
             <summary>
             Add or Update a Directory in a zip archive.
             If the directory has already been added to the archive,
             its contents are updated.  If not, then the directory is added.
             </summary>
            
             <remarks>
             If the specified directory does not exist in the archive, then this method is equivalent to
             calling AddDirectory().  If the specified directory already exists in the archive, then this 
             method updates any existing entries, and adds any new entries. Any entries that are in the 
             zip archive but not in the specified directory, are left alone.  In other words, the contents of 
             the zip file is a union of the previous contents and the new files.
             </remarks>
            
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.UpdateFile(System.String)"/>
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.AddDirectory(System.String)"/>
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.UpdateItem(System.String)"/>
            
             <param name="directoryName">The path to the directory to be added to the zip archive, 
             or updated in the zip archive.</param>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.UpdateDirectory(System.String,System.String)">
             <summary>
             Add or Update a directory in the zip archive at the specified root directory in the archive.  
             If the directory has already been added to the archive,
             its contents are updated.  If not, then the directory is added.
             </summary>
            
             <remarks>
             If the specified directory does not exist in the archive, then this method is equivalent to
             calling AddDirectory().  If the specified directory already exists in the archive, then this 
             method updates any existing entries, and adds any new entries. Any entries that are in the 
             zip archive but not in the specified directory, are left alone.  In other words, the contents of 
             the zip file is a union of the previous contents and the new files.
             </remarks>
            
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.UpdateFile(System.String,System.String)"/>
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.AddDirectory(System.String,System.String)"/>
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.UpdateItem(System.String,System.String)"/>
            
             <param name="directoryName">The path to the directory to be added to the zip archive, 
             or updated in the zip archive.</param>
            
             <param name="directoryPathInArchive">
             Specifies a directory path to use to override any path in the ItemName.
             This path may, or may not, correspond to a real directory in the current filesystem.
             If the files within the zip are later extracted, this is the path used for the extracted file. 
             Passing null (nothing in VB) will use the path on the FileName, if any.  Passing the empty string ("")
             will insert the item at the root path within the archive. 
             </param>
             
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.UpdateItem(System.String)">
             <summary>
             Add or Update a File or Directory in the zip archive. This
             is useful when the application is not sure or does not care
             if the entries in the existing zip archive already exist.
             </summary>
            
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.AddItem(System.String)"/>
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.UpdateFile(System.String)"/>
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.UpdateDirectory(System.String)"/>
            
             <param name="itemName">the path to the file or directory to be added or updated.</param>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.UpdateItem(System.String,System.String)">
             <summary>
             Add or Update a File or Directory.  This is useful when the application is not sure or does not 
             care if the entries in the existing zip archive already exist.  
             </summary>
            
             <remarks>
             <para>
             This version of the method allows the caller to explicitly specify the 
             directory path to be used for the item being added to the archive.  The entry or entries 
             that are added or updated will use the specified <c>DirectoryPathInArchive</c>. Extracting
             the entry from the archive will result in a file stored in that directory path. 
             </para>
             </remarks>
            
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.AddItem(System.String,System.String)"/>
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.UpdateFile(System.String,System.String)"/>
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.UpdateDirectory(System.String,System.String)"/>
            
             <param name="itemName">The path for the File or Directory to be added or updated.</param>
             <param name="directoryPathInArchive">
             Specifies a directory path to use to override any path in the ItemName.
             This path may, or may not, correspond to a real directory in the current filesystem.
             If the files within the zip are later extracted, this is the path used for the extracted file. 
             Passing null (nothing in VB) will use the path on the FileName, if any.  Passing the empty string ("")
             will insert the item at the root path within the archive. 
             </param>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.AddFileStream(System.String,System.String,System.IO.Stream)">
             <summary>
             Uses the given stream as input to create an entry in the ZipFile, with the 
             given FileName and given Directory Path.  
             </summary>
            
             <remarks>
             <para>
             The stream must remain open and readable at least through the call to 
             <c>ZipFile.Save</c>.
             </para>
             <para>
             Encryption will be used on the stream data when saving the 
             ZipFile, if the Password is set on the ZipFile object prior to calling
             this method.</para>
             </remarks>
            
             <example>
             <code lang="C#">
             String ZipToCreate = "Content.zip";
             String FileNameInArchive = "Content-From-Stream.bin";
             using (ZipFile zip = new ZipFile(ZipToCreate))
             {
               ZipEntry entry= zip.AddFileStream(FileNameInArchive, "basedirectory", StreamToRead);
               entry.Comment = "The content for entry in the zip file was obtained from a stream";
               zip.AddFile("Readme.txt");
               zip.Save();
             }
             
             </code>
             <code lang="VB">
             Dim ZipToCreate As String = "Content.zip"
             Dim FileNameInArchive As String = "Content-From-Stream.bin"
             Using zip As ZipFile = New ZipFile(ZipToCreate)
               Dim entry as ZipEntry = zip.AddFileStream(FileNameInArchive, "basedirectory", Me.StreamToRead)
               entry.Comment = "The content for entry in the zip file was obtained from a stream"
               zip.AddFile("Readme.txt")
               zip.Save
             End Using
             </code>
             </example>
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.UpdateFileStream(System.String,System.String,System.IO.Stream)"/>
            
             <param name="fileName">FileName which is shown in the ZIP File</param>
             <param name="directoryPathInArchive">
             Specifies a directory path to use to override any path in the ItemName.
             This path may, or may not, correspond to a real directory in the current filesystem.
             If the files within the zip are later extracted, this is the path used for the extracted file. 
             Passing null (nothing in VB) will use the path on the FileName, if any.  Passing the empty string ("")
             will insert the item at the root path within the archive. 
             </param>
             <param name="stream">the input stream from which to grab content for the file</param>
             <returns>The ZipEntry added.</returns>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.AddFileFromString(System.String,System.String,System.String)">
            <summary>
            Adds an entry into the zip archive using the given filename and directory path within the archive,
            and the given content for the file.  No file is created in the filesystem.  
            </summary>
            <param name="content">The content of the file, should it be extracted from the zip.</param>
            <param name="fileName">The filename to use within the archive.</param>
            <param name="directoryPathInArchive">
            Specifies a driectory path to use to override any path in the ItemName.
            This path may, or may not, correspond to a real directory in the current filesystem.
            If the files within the zip are later extracted, this is the path used for the extracted file. 
            Passing null (nothing in VB) will use the path on the FileName, if any.  Passing the empty string ("")
            will insert the item at the root path within the archive. 
            </param>
            <returns>The ZipEntry added.</returns>
            
            <example>
            This example shows how to add an entry to the zipfile, using a string as content for that entry. 
            <code lang="C#">
            string Content = "This string will be the content of the Readme.txt file in the zip archive.";
            using (ZipFile zip1 = new ZipFile())
            {
              zip1.AddFile("MyDocuments\\Resume.doc", "files");
              zip1.AddFileFromString("Readme.txt", "", Content); 
              zip1.Comment = "This zip file was created at " + System.DateTime.Now.ToString("G");
              zip1.Save("Content.zip");
            }
            
            </code>
            <code lang="VB">
            Public Sub Run()
              Dim Content As String = "This string will be the content of the Readme.txt file in the zip archive."
              Using zip1 As ZipFile = New ZipFile
                zip1.AddFileFromString("Readme.txt", "", Content)
                zip1.AddFile("MyDocuments\Resume.doc", "files")
                zip1.Comment = ("This zip file was created at " &amp; DateTime.Now.ToString("G"))
                zip1.Save("Content.zip")
              End Using
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.UpdateFileStream(System.String,System.String,System.IO.Stream)">
             <summary>
             Updates the given entry in the zipFile, using the given stream as input, and the
             given FileName and given Directory Path.  Encryption will be used on the 
             stream data if the Password is set on the ZipFile object, prior to calling
             this method.
             </summary>
            
             <remarks>
             The stream must remain open and readable at least through the call to 
             <c>ZipFile.Save</c>.
             </remarks>
            
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.AddFileStream(System.String,System.String,System.IO.Stream)"/>
            
             <param name="fileName">FileName which is shown in the ZIP File</param>
             <param name="directoryPathInArchive">The root path to be used in the ZIP archive, 
             for the entry added from the stream.</param>
             <param name="stream">The Input Stream to read file data from.</param>
             <returns>The ZipEntry added.</returns>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.AddDirectory(System.String)">
             <summary>
             Adds the contents of a filesystem directory to a Zip file archive. 
             </summary>
             
             <remarks>
             
             <para>
             The name of the directory may be 
             a relative path or a fully-qualified path. Any files within the named 
             directory are added to the archive.  Any subdirectories within the named
             directory are also added to the archive, recursively. 
             </para>
             
             <para>
             Top-level entries in the named directory will appear as top-level 
             entries in the zip archive.  Entries in subdirectories in the named 
             directory will result in entries in subdirectories in the zip archive.
             </para>
             
             <para>
             If you want the entries to appear in a containing directory in the zip
             archive itself, then you should call the AddDirectory() overload that allows
             you to explicitly specify a containing directory.
             </para>
             
             </remarks>
             
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.AddItem(System.String)"/>
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.AddFile(System.String)"/>
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.UpdateDirectory(System.String)"/>
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.AddDirectory(System.String,System.String)"/>
            
             <overloads>This method has 2 overloads.</overloads>
             
             <param name="directoryName">The name of the directory to add.</param>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.AddDirectory(System.String,System.String)">
             <summary>
             Adds the contents of a filesystem directory to a Zip file archive, 
             overriding the path to be used for entries in the archive. 
             </summary>
             
             <remarks>
             <para>
             The name of the directory may be a relative path or a fully-qualified
             path. The add operation is recursive, so that any files or subdirectories
             within the name directory are also added to the archive.
             </para>
             </remarks>
             
             <example>
             <para>
             In this code, calling the ZipUp() method with a value of "c:\temp" for the
             directory parameter will result in a zip file structure in which all entries
             are contained in a toplevel "temp" directory.
             </para>
            
             <code lang="C#">
             public void ZipUp(string targetZip, string directory)
             {
               using (var zip = new ZipFile())
               {
                 zip.AddDirectory(directory, System.IO.Path.GetFileName(directory));
                 zip.Save(targetZip);
               }
             }
             </code>
             </example>
             
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.AddItem(System.String,System.String)"/>
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.AddFile(System.String,System.String)"/>
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.UpdateDirectory(System.String,System.String)"/>
            
             <param name="directoryName">The name of the directory to add.</param>
             
             <param name="directoryPathInArchive">
             Specifies a directory path to use to override any path in the DirectoryName.
             This path may, or may not, correspond to a real directory in the current filesystem.
             If the zip is later extracted, this is the path used for the extracted file or directory. 
             Passing null (nothing in VB) or the empty string ("")
             will insert the items at the root path within the archive. 
             </param>
             
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.AddDirectoryByName(System.String)">
             <summary>
             Creates a directory in the zip archive.  
             </summary>
             
             <remarks>
             
             <para>
             Use this when you want to create a directory in the archive but there is no
             corresponding filesystem representation for that directory.
             </para>
            
             <para>
             You will probably not need to do this in your code. One of the only times
             you will want to do this is if you want an empty directory in the zip
             archive.  If you add a file to a zip archive that is stored within a
             multi-level directory, all of the directory tree is implicitly created in
             the zip archive.  
             </para>
             
             </remarks>
             
             <param name="directoryNameInArchive">
             The name of the directory to create in the archive.
             </param>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.Save">
             <summary>
             Saves the Zip archive, using the name given when the ZipFile was instantiated. 
             </summary>
            
             <remarks>
             <para>
             The zip file is written to storage only when the caller calls <c>Save</c>.  
             The Save operation writes the zip content to a temporary file. 
             Then, if the zip file already exists (for example when adding an item to a zip archive)
             this method will replace the existing zip file with this temporary file.
             If the zip file does not already exist, the temporary file is renamed 
             to the desired name.  
             </para>
            
             <para>
             When using a filesystem file for the Zip output, it is possible to call
             <c>Save</c> multiple times on the ZipFile instance. With each call the zip content
             is written to the output file. When saving to a <c>Stream</c>, after the initial
             call to <c>Save</c>, additional calls to <c>Save</c> will throw. This is because the
             stream is assumed to be a write-only stream, and after the initial <c>Save</c>, it
             is not possible to seek backwards and "unwrite" the zip file data.
             </para>
            
             <para>
             Data for entries that have been added to the <c>ZipFile</c> instance is written
             to the output when the <c>Save</c> method is called. This means that the input
             streams for those entries must be available at the time the application
             calls <c>Save</c>.  If, for example, the application adds entries with
             <c>AddFileStream</c> using a dynamically-allocated <c>MemoryStream</c>,
             the memory stream must not have been disposed before the call to <c>Save</c>.
             </para>
            
             <para>
             When using the zip library within an ASP.NET application, you may wish to set the
             <c>TempFileFolder</c> property on the <c>ZipFile</c> instance before calling Save().
             </para>
             </remarks>
            
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.AddFileStream(System.String,System.String,System.IO.Stream)"/>
            
             <exception cref="T:Ionic.Utils.Zip.BadStateException">
             Thrown if you haven't specified a location or stream for saving the zip,
             either in the constructor or by setting the Name property. 
             </exception>
            
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.Save(System.String)">
             <summary>
             Save the file to a new zipfile, with the given name. 
             </summary>
             
             <remarks>
             <para>
             This is handy when reading a zip archive from a stream 
             and you want to modify the archive (add a file, change a 
             comment, etc) and then save it to a file. 
             </para>
             <para>
             It also works if you create a new ZipFile for writing to a 
             stream, and then you also want to write it to a filesystem file. 
             In that case, call the Save() method, and then also call this method with
             a filename. 
             </para>
             </remarks>
             
             <exception cref="T:System.ArgumentException">
             Thrown if you specify a directory for the filename.
             </exception>
            
             <param name="zipFileName">
             The name of the zip archive to save to. Existing files will 
             be overwritten with great prejudice.
             </param>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.OnSaveProgress(System.Int32,System.String)">
            <summary>
            Fires the <see cref="E:Ionic.Utils.Zip.ZipFile.SaveProgress"/> method.
            </summary>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.OnExtractProgress(System.Int32,System.String,System.String,System.Boolean)">
            <summary>
            Fires the <see cref="E:Ionic.Utils.Zip.ZipFile.ExtractProgress"/> method.
            </summary>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.IsZipFile(System.String)">
            <summary>
            Checks the given file to see if it appears to be a valid zip file.
            </summary>
            <remarks>
            This method opens the file, and reads in the zip header, as well as the
            zip directory structure.  If everything succeeds, then the method
            returns true.  If anything fails - for example if an incorrect signature
            is found, the the method returns false.  This method also returns false
            (no exception) for a file that does not exist.  Because this method does
            not actually read in the zip content, decrypt, and check CRCs, it is
            possible for this method to return true in the case the zip file is
            corrupted.
            </remarks>
            <param name="fileName">The file to check.</param>
            <returns>true if the file appears to be a zip file.</returns>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.Read(System.String)">
             <summary>
             Reads a zip file archive and returns the instance.  
             </summary>
             
             <remarks>
             <para>
             The stream is read using the default <c>System.Text.Encoding</c>, which is the <c>IBM437</c> codepage.  
             </para>
             </remarks>
             <exception cref="T:System.Exception">
             Thrown if the ZipFile cannot be read. The implementation of this 
             method relies on <c>System.IO.File.OpenRead</c>, which can throw
             a variety of exceptions, including specific exceptions if a file
             is not found, an unauthorized access exception, exceptions for
             poorly formatted filenames, and so on. 
             </exception>
             
             <param name="zipFileName">
             The name of the zip archive to open.  
             This can be a fully-qualified or relative pathname.
             </param>
             
             <overloads>This method has a bunch of interesting overloads. They are all static (Shared in VB)</overloads>
            
             <returns>The instance read from the zip archive.</returns>
             
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.Read(System.String,System.IO.TextWriter)">
             <summary>
             Reads a zip file archive using the specified text encoding, and returns the instance.  
             </summary>
             
             <remarks>
             <para>
             This version of the method allows the caller to pass in a <c>TextWriter</c>.  
             The ZipFile is read in using the default IBM437 encoding for entries where no
             encoding is specified.
             </para>
             <para>
             The stream is read using the default <c>System.Text.Encoding</c>, which is the <c>IBM437</c> codepage.  
             </para>
             </remarks>
             
             <example>
             <code lang="C#">
             var sw = new System.IO.StringWriter();
             using (ZipFile zip =  ZipFile.Read("PackedDocuments.zip", sw))
             {
               var Threshold = new DateTime(2007,7,4);
               // We cannot remove the entry from the list, within the context of 
               // an enumeration of said list.
               // So we add the doomed entry to a list to be removed later.
               // pass 1: mark the entries for removal
               var MarkedEntries = new System.Collections.Generic.List&lt;ZipEntry&gt;();
               foreach (ZipEntry e in zip)
               {
                 if (e.LastModified &lt; Threshold)
                   MarkedEntries.Add(e);
               }
               // pass 2: actually remove the entry. 
               foreach (ZipEntry zombie in MarkedEntries)
                  zip.RemoveEntry(zombie);
               zip.Comment = "This archive has been updated.";
               zip.Save();
             }
             // can now use contents of sw, eg store in an audit log
             </code>
            
             <code lang="VB">
               Dim sw As New System.IO.StringWriter
               Using zip As ZipFile = ZipFile.Read("PackedDocuments.zip", sw)
                   Dim Threshold As New DateTime(2007, 7, 4)
                   ' We cannot remove the entry from the list, within the context of 
                   ' an enumeration of said list.
                   ' So we add the doomed entry to a list to be removed later.
                   ' pass 1: mark the entries for removal
                   Dim MarkedEntries As New System.Collections.Generic.List(Of ZipEntry)
                   Dim e As ZipEntry
                   For Each e In zip
                       If (e.LastModified &lt; Threshold) Then
                           MarkedEntries.Add(e)
                       End If
                   Next
                   ' pass 2: actually remove the entry. 
                   Dim zombie As ZipEntry
                   For Each zombie In MarkedEntries
                       zip.RemoveEntry(zombie)
                   Next
                   zip.Comment = "This archive has been updated."
                   zip.Save
               End Using
               ' can now use contents of sw, eg store in an audit log
             </code>
             </example>
             
             <exception cref="T:System.Exception">
             Thrown if the zipfile cannot be read. The implementation of this 
             method relies on <c>System.IO.File.OpenRead</c>, which can throw
             a variety of exceptions, including specific exceptions if a file
             is not found, an unauthorized access exception, exceptions for
             poorly formatted filenames, and so on. 
             </exception>
             
             <param name="zipFileName">
             The name of the zip archive to open.  
             This can be a fully-qualified or relative pathname.
             </param>
             
             <param name="statusMessageWriter">
             The <c>System.IO.TextWriter</c> to use for writing verbose status messages during operations
             on the zip archive.  A console application may wish to pass <c>System.Console.Out</c> to get 
             messages on the Console. A graphical or headless application may wish to capture the messages 
             in a different <c>TextWriter</c>, such as a <c>System.IO.StringWriter</c>. 
             </param>
             
             <returns>The instance read from the zip archive.</returns>
             
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.Read(System.String,System.Text.Encoding)">
            <summary>
            Reads a zip file archive using the specified text encoding, and returns the instance.  
            </summary>
            
            <remarks>
            <para>
            This version of the method allows the caller to pass in an <c>Encoding</c>.  
            The ZipFile is read in using the specified encoding for entries where no
            encoding is specified.
            </para>
            <para>
            See the <see cref="M:Ionic.Utils.Zip.ZipFile.Read(System.String,System.IO.TextWriter)"/> overload for a code example.
            </para>
            </remarks>
            
            <exception cref="T:System.Exception">
            Thrown if the zipfile cannot be read. The implementation of this 
            method relies on <c>System.IO.File.OpenRead</c>, which can throw
            a variety of exceptions, including specific exceptions if a file
            is not found, an unauthorized access exception, exceptions for
            poorly formatted filenames, and so on. 
            </exception>
            
            <param name="zipFileName">
            The name of the zip archive to open.  
            This can be a fully-qualified or relative pathname.
            </param>
            
            <param name="encoding">
            The <c>System.Text.Encoding</c> to use when reading in the zip archive. Be careful specifying the
            encoding.  If the value you use here is not the same as the Encoding used when the zip archive was 
            created (possibly by a different archiver) you will get unexpected results.  
            </param>
            
            <returns>The instance read from the zip archive.</returns>
            
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.Read(System.String,System.IO.TextWriter,System.Text.Encoding)">
            <summary>
            Reads a zip file archive using the specified text encoding, and returns the instance.  
            </summary>
            
            <remarks>
            <para>
            This version of the method allows the caller to pass in a <c>TextWriter</c> and an <c>Encoding</c>.  
            </para>
            <para>
            See the <see cref="M:Ionic.Utils.Zip.ZipFile.Read(System.String,System.IO.TextWriter)"/> overload for a code example.
            </para>
            </remarks>
            
            <exception cref="T:System.Exception">
            Thrown if the zipfile cannot be read. The implementation of this 
            method relies on <c>System.IO.File.OpenRead</c>, which can throw
            a variety of exceptions, including specific exceptions if a file
            is not found, an unauthorized access exception, exceptions for
            poorly formatted filenames, and so on. 
            </exception>
            
            <param name="zipFileName">
            The name of the zip archive to open.  
            This can be a fully-qualified or relative pathname.
            </param>
            
            <param name="statusMessageWriter">
            The <c>System.IO.TextWriter</c> to use for writing verbose status messages during operations
            on the zip archive.  A console application may wish to pass <c>System.Console.Out</c> to get 
            messages on the Console. A graphical or headless application may wish to capture the messages 
            in a different <c>TextWriter</c>, such as a <c>System.IO.StringWriter</c>. 
            </param>
            
            <param name="encoding">
            The <c>System.Text.Encoding</c> to use when reading in the zip archive. Be careful specifying the
            encoding.  If the value you use here is not the same as the Encoding used when the zip archive was 
            created (possibly by a different archiver) you will get unexpected results.  
            </param>
            
            <returns>The instance read from the zip archive.</returns>
            
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.Read(System.IO.Stream)">
             <summary>
             Reads a zip archive from a stream.
             </summary>
            
             <remarks>
             <para>
             This is useful when when the zip archive content is available from 
             an already-open stream. The stream must be open and readable when calling this
             method.  The stream is left open when the reading is completed. 
             </para>
             <para>
             The stream is read using the default <c>System.Text.Encoding</c>, which is the <c>IBM437</c> codepage.  
             </para>
             </remarks>
            
             <example>
             This example shows how to Read zip content from a stream, and extract
             one entry into a different stream. In this example, the filename
             "NameOfEntryInArchive.doc", refers only to the name of the entry
             within the zip archive.  A file by that name is not created in the
             filesystem.  The I/O is done strictly with the given streams.
             <code>
             using (ZipFile zip = ZipFile.Read(InputStream))
             {
               zip.Extract("NameOfEntryInArchive.doc", OutputStream);
             }
             </code>
             <code lang="VB">
             Using zip as ZipFile = ZipFile.Read(InputStream)
               zip.Extract("NameOfEntryInArchive.doc", OutputStream)
             End Using
             </code>
             </example>
            
             <param name="zipStream">the stream containing the zip data.</param>
             <returns>an instance of ZipFile</returns>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.Read(System.IO.Stream,System.IO.TextWriter)">
             <summary>
             Reads a zip archive from a stream, using the specified TextWriter for status messages.
             </summary>
             
             <remarks>
             <para>
             This method is useful when when the zip archive content is available from 
             an already-open stream. The stream must be open and readable when calling this
             method.  The stream is left open when the reading is completed. 
             </para>
             
             <para>
             The stream is read using the default <c>System.Text.Encoding</c>, which is the <c>IBM437</c> codepage.  
             For more information on the encoding, see the <see cref="P:Ionic.Utils.Zip.ZipFile.Encoding">Encoding</see> property.
             </para>
             </remarks>
            
             <exception cref="T:Ionic.Utils.Zip.ZipException">
             Thrown if zipStream is null.
             In this case, the inner exception is an ArgumentException.
             </exception>
            
             <param name="zipStream">the stream containing the zip data.</param>
             
             <param name="statusMessageWriter">
             The <c>System.IO.TextWriter</c> to which verbose status messages are written during operations on the ZipFile.  
             For example, in a console application, System.Console.Out works, and will get a message for each entry added to the ZipFile. 
             If the TextWriter is null, no verbose messages are written. 
             </param>
             
             <returns>an instance of ZipFile</returns>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.Read(System.IO.Stream,System.Text.Encoding)">
             <summary>
             Reads a zip archive from a stream, using the specified encoding.
             </summary>
             
             <remarks>
             <para>
             This method is useful when when the zip archive content is available from 
             an already-open stream. The stream must be open and readable when calling this
             method.  The stream is left open when the reading is completed. 
             </para>
             </remarks>
            
             <exception cref="T:Ionic.Utils.Zip.ZipException">
             Thrown if zipStream is null.
             In this case, the inner exception is an ArgumentException.
             </exception>
            
             <param name="zipStream">the stream containing the zip data.</param>
             
             <param name="encoding">
             The text encoding to use when reading entries that do not have the UTF-8 encoding bit set. 
             See the <see cref="P:Ionic.Utils.Zip.ZipFile.Encoding">Encoding</see> property for more information. 
             </param>
             
             <returns>an instance of ZipFile</returns>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.Read(System.IO.Stream,System.IO.TextWriter,System.Text.Encoding)">
             <summary>
             Reads a zip archive from a stream, using the specified text Encoding and the specified TextWriter for status messages.
             </summary>
             <remarks>
             <para>
             This method is useful when when the zip archive content is available from 
             an already-open stream. The stream must be open and readable when calling this
             method.  The stream is left open when the reading is completed. 
             </para>
             </remarks>
            
             <exception cref="T:Ionic.Utils.Zip.ZipException">
             Thrown if zipStream is null.
             In this case, the inner exception is an ArgumentException.
             </exception>
            
             <param name="zipStream">the stream containing the zip data.</param>
             <param name="statusMessageWriter">
             The <c>System.IO.TextWriter</c> to which verbose status messages are written during operations on the ZipFile.  
             For example, in a console application, System.Console.Out works, and will get a message for each entry added to the ZipFile. 
             If the TextWriter is null, no verbose messages are written. 
             </param>
             <param name="encoding">
             The text encoding to use when reading entries that do not have the UTF-8 encoding bit set. 
             See the <see cref="P:Ionic.Utils.Zip.ZipFile.Encoding">Encoding</see> property for more information. 
             </param>
             <returns>an instance of ZipFile</returns>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.Read(System.Byte[])">
            <summary>
            Reads a zip archive from a byte array.
            </summary>
            
            <remarks>
            This is useful when the data for the zipfile is contained in a byte array, 
            for example, downloaded from an FTP server without being saved to a
            filesystem. 
            </remarks>
            
            <param name="buffer">
            The byte array containing the zip data.  
            (I don't know why, but sometimes the compiled helpfuile (.chm) indicates a 2d 
            array when it is just one-dimensional.  This is a one-dimensional array.)
            </param>
            
            <returns>an instance of ZipFile. The name on the ZipFile will be null (nothing in VB)). </returns>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.Read(System.Byte[],System.IO.TextWriter)">
            <summary>
            Reads a zip archive from a byte array, using the given StatusMessageWriter.
            </summary>
            
            <remarks>
            <para>
            This method is useful when the data for the zipfile is contained in a byte array, for
            example when retrieving the data from a database or other non-filesystem store.  
            The default Text Encoding (IBM437) is used to read the zipfile data.
            </para>
            
            </remarks>
            
            <param name="buffer">the byte array containing the zip data.</param>
            <param name="statusMessageWriter">
            The <c>System.IO.TextWriter</c> to which verbose status messages are written during operations on the ZipFile.  
            For example, in a console application, System.Console.Out works, and will get a message for each entry added to the ZipFile. 
            If the TextWriter is null, no verbose messages are written. 
            </param>
            
            <returns>an instance of ZipFile. The name is set to null.</returns>
            
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.Read(System.Byte[],System.IO.TextWriter,System.Text.Encoding)">
            <summary>
            Reads a zip archive from a byte array, using the given StatusMessageWriter and text Encoding.
            </summary>
            
            <remarks>
            <para>
            This method is useful when the data for the zipfile is contained in a byte array, for
            example when retrieving the data from a database or other non-filesystem store.  
            </para>
            
            </remarks>
            
            <param name="buffer">the byte array containing the zip data.</param>
            <param name="statusMessageWriter">
            The <c>System.IO.TextWriter</c> to which verbose status messages are written during operations on the ZipFile.  
            For example, in a console application, System.Console.Out works, and will get a message for each entry added to the ZipFile. 
            If the TextWriter is null, no verbose messages are written. 
            </param>
            
            <param name="encoding">
            The text encoding to use when reading entries that do not have the UTF-8 encoding bit set. 
            See the <see cref="P:Ionic.Utils.Zip.ZipFile.Encoding">Encoding</see> property for more information. 
            </param>
                    
            <returns>an instance of ZipFile. The name is set to null.</returns>
            
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.GetEnumerator">
             <summary>
             Generic IEnumerator support, for use of a ZipFile in a foreach construct.  
             </summary>
            
             <remarks>
             You probably do not want to call <c>GetEnumerator</c> explicitly. Instead 
             it is implicitly called when you use a <c>foreach</c> loop in C#, or a 
             <c>For Each</c> loop in VB.
             </remarks>
            
             <example>
             This example reads a zipfile of a given name, then enumerates the 
             entries in that zip file, and displays the information about each 
             entry on the Console.
             <code>
             using (ZipFile zip = ZipFile.Read(zipfile))
             {
               bool header = true;
               foreach (ZipEntry e in zip)
               {
                 if (header)
                 {
                    System.Console.WriteLine("Zipfile: {0}", zip.Name);
                    System.Console.WriteLine("Version Needed: 0x{0:X2}", e.VersionNeeded);
                    System.Console.WriteLine("BitField: 0x{0:X2}", e.BitField);
                    System.Console.WriteLine("Compression Method: 0x{0:X2}", e.CompressionMethod);
                    System.Console.WriteLine("\n{1,-22} {2,-6} {3,4}   {4,-8}  {0}",
                                 "Filename", "Modified", "Size", "Ratio", "Packed");
                    System.Console.WriteLine(new System.String('-', 72));
                    header = false;
                 }
            
                 System.Console.WriteLine("{1,-22} {2,-6} {3,4:F0}%   {4,-8}  {0}",
                             e.FileName,
                             e.LastModified.ToString("yyyy-MM-dd HH:mm:ss"),
                             e.UncompressedSize,
                             e.CompressionRatio,
                             e.CompressedSize);
            
                 e.Extract();
               }
             }
             </code>
            
             <code lang="VB">
               Dim ZipFileToExtract As String = "c:\foo.zip"
               Using zip As ZipFile = ZipFile.Read(ZipFileToExtract)
                   Dim header As Boolean = True
                   Dim e As ZipEntry
                   For Each e In zip
                       If header Then
                           Console.WriteLine("Zipfile: {0}", zip.Name)
                           Console.WriteLine("Version Needed: 0x{0:X2}", e.VersionNeeded)
                           Console.WriteLine("BitField: 0x{0:X2}", e.BitField)
                           Console.WriteLine("Compression Method: 0x{0:X2}", e.CompressionMethod)
                           Console.WriteLine(ChrW(10) &amp; "{1,-22} {2,-6} {3,4}   {4,-8}  {0}", _
                             "Filename", "Modified", "Size", "Ratio", "Packed" )
                           Console.WriteLine(New String("-"c, 72))
                           header = False
                       End If
                       Console.WriteLine("{1,-22} {2,-6} {3,4:F0}%   {4,-8}  {0}", _
                         e.FileName, _
                         e.LastModified.ToString("yyyy-MM-dd HH:mm:ss"), _
                         e.UncompressedSize, _
                         e.CompressionRatio, _
                         e.CompressedSize )
                       e.Extract
                   Next
               End Using
             </code>
             </example>
             
             <returns>A generic enumerator suitable for use  within a foreach loop.</returns>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            IEnumerator support, for use of a ZipFile in a foreach construct.  
            </summary>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.ExtractAll(System.String)">
             <summary>
             Extracts all of the items in the zip archive, to the specified path in the filesystem.
             The path can be relative or fully-qualified. 
             </summary>
            
             <remarks>
             <para>
             If an extraction of a file from the zip archive would overwrite an existing file
             in the filesystem, the file will not be overwritten and an exception will be
             thrown. To avoid this, use the overload that allows you to specify that you want
             to overwrite existing files.
             </para>
            
             <para>
             This method will send verbose output messages to the StatusMessageTextWriter, if it 
             is set on the ZipFile instance. 
             </para>
            
             <para>
             You may also wish to take advantage of the <c>ExtractStarted</c>,
             <c>ExtractProgress</c>, and <c>ExtractCompleted</c> events.
             </para>
            
             </remarks>
            
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.ExtractAll(System.String,System.Boolean)"/>
             <seealso cref="E:Ionic.Utils.Zip.ZipFile.ExtractStarted"/>
             <seealso cref="E:Ionic.Utils.Zip.ZipFile.ExtractProgress"/>
            
             <param name="path">The path to which the contents of the zip archive should be extracted.</param>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.ExtractAll(System.String,System.Boolean)">
             <summary>
             Extracts all of the items in the zip archive, to the specified path in the filesystem,  
             optionally overwriting any existing files. The path can be relative or fully-qualified. 
             </summary>
            
             <remarks>
             This method will send verbose output messages to the StatusMessageTextWriter, if it 
             is set on the ZipFile instance. 
             </remarks>
            
             <example>
             This example extracts all the entries in a zip archive file, 
             to the specified target directory.  It overwrites any existing files.
             It also handles exceptions that may be thrown, such as unauthorized 
             access exceptions.
             <code>
             String TargetDirectory= "c:\\temp\\unpack";
             try 
             {
               using(ZipFile zip= ZipFile.Read(ZipFileToExtract))
               {
                 zip.ExtractAll(TargetDirectory, true);
               }
             }
             catch (System.Exception ex1)
             {
               System.Console.Error.WriteLine("exception: {0}", ex1);
             }
             </code>
             
             <code lang="VB">
               Dim TargetDirectory As String = "c:\temp\unpack"
               Try 
                   Using zip As ZipFile = ZipFile.Read(ZipFileToExtract)
                       zip.ExtractAll(TargetDirectory, True)
                   End Using
               Catch ex1 As Exception
                   Console.Error.WriteLine("exception: {0}", ex1.ToString)
               End Try
             </code>
             </example>
             
             <param name="path">the path to which the contents of the zipfile are extracted.</param>
             <param name="wantOverwrite">true to overwrite any existing files on extraction</param>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.Extract(System.String)">
            <summary>
            Extract a single item from the archive.  The file, including any relative
            qualifying path, is created at the current working directory.  
            </summary>
            
            <remarks>
            Calling this method, the entry is extracted using the Password that is 
            specified on the ZipFile instance. If you have not set the Password property, then
            the password is null, and the entry is extracted with no password.
            </remarks>
            
            <param name="fileName">
            The file to extract. It must be the exact filename, including the path
            contained in the archive, if any. The filename match is not case-sensitive by
            default; you can use the <c>CaseSensitiveRetrieval</c> property to change
            this behavior.
            </param>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.Extract(System.String,System.String)">
             <summary>
             Extract a single item from the archive.  The file, including any relative
             qualifying path, is created at the current working directory.  
             </summary>
            
             <remarks>
             Calling this method, the entry is extracted using the Password that is 
             specified on the ZipFile instance. If you have not set the Password property, then
             the password is null, and the entry is extracted with no password.
             </remarks>
             
             <param name="fileName">
             the file to extract. It must be the exact filename, including the path
             contained in the archive, if any. The filename match is not case-sensitive by
             default; you can use the <c>CaseSensitiveRetrieval</c> property to change
             this behavior.
             </param>
             <param name="directoryName">the directory into which to extract. It should exist.</param>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.Extract(System.String,System.Boolean)">
             <summary>
             Extract a single item from the archive, potentially overwriting  
             any existing file in the filesystem by the same name. The file, including any relative 
             qualifying path, is created at the current working directory.  
             </summary>
             
             <remarks>
             Calling this method, the entry is extracted using the Password that is 
             specified on the ZipFile instance. If you have not set the Password property, then
             the password is null, and the entry is extracted with no password.
             </remarks>
             
             <param name="fileName">
             The file to extract. It must be the exact filename, including the path contained in the 
             archive, if any. The filename match is not case-sensitive by default; you can use the <c>CaseSensitiveRetrieval</c> 
             property to change this behavior.
             The pathname can use forward-slashes or backward slashes.
             </param>
            
             <seealso cref="P:Ionic.Utils.Zip.ZipFile.CaseSensitiveRetrieval"/>
            
             <param name="wantOverwrite">True if the caller wants to overwrite any existing files by the given name.</param>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.Extract(System.String,System.String,System.Boolean)">
            <summary>
            Extract a single item from the archive, into the specified directory, potentially overwriting  
            any existing file in the filesystem by the same name. The file, including any relative 
            qualifying path, is created in the specified directory.  
            </summary>
            
            <remarks>
            Calling this method, the entry is extracted using the Password that is 
            specified on the ZipFile instance. If you have not set the Password property, then
            the password is null, and the entry is extracted with no password.
            </remarks>
            
            <param name="fileName">
            The file to extract. It must be the exact filename, including the path contained in the archive, 
            if any. The filename match is not case-sensitive by default; you can use the <c>CaseSensitiveRetrieval</c> 
            property to change this behavior. The pathname can use forward-slashes or backward slashes.
            </param>
            <param name="directoryName">the directory into which to extract. It should exist.</param>
            <param name="wantOverwrite">True if the caller wants to overwrite any existing files by the given name.</param>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.Extract(System.String,System.IO.Stream)">
             <summary>
             Extract a single specified file from the archive, to the given stream.  This is 
             useful when extracting to Console.Out or to a memory stream, for example. 
             </summary>
             
             <remarks>
             Calling this method, the entry is extracted using the Password that is 
             specified on the ZipFile instance. If you have not set the Password property, then
             the password is null, and the entry is extracted with no password.
             </remarks>
             
             <exception cref="T:Ionic.Utils.Zip.ZipException">
             Thrown if the outputStream is not writable, or if the filename is 
             null or empty. The inner exception is an ArgumentException in each case.
             </exception>
            
             <param name="fileName">
             the file to extract. It should include pathnames used in the archive, if any.
             The filename match is not case-sensitive by default; you can use the
             <c>CaseSensitiveRetrieval</c> property to change this behavior.The
             application can specify pathnames using forward-slashes or backward slashes.
             </param>
            
             <param name="outputStream">
             the stream to which the extacted, decompressed file data is written. 
             The stream must be writable.
             </param>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.RemoveEntry(Ionic.Utils.Zip.ZipEntry)">
             <summary>
             Removes the given ZipEntry from the zip archive.  
             </summary>
             
             <remarks>
             <para>
             After calling <c>RemoveEntry</c>, the application must call <c>Save</c> to make the 
             changes permanent.  
             </para>
             </remarks>
            
             <exception cref="T:System.ArgumentException">
             Thrown if the specified ZipEntry does not exist in the ZipFile.
             </exception>
            
             <example>
             In this example, all entries in the zip archive dating from before December 31st, 2007, are
             removed from the archive.
             <code>
             System.DateTime Threshold = new System.DateTime(2007,12,31);
             using (ZipFile zip = new ZipFile(ZipFileToRead))
             {
               var EntriesToRemove = new System.Collections.Generic.List&lt;ZipEntry&gt;();
               foreach (ZipEntry e in zip)
               {
                 if (e.LastModified &lt; Threshold)
                 {
                   // We cannot remove the entry from the list, within the context of 
                   // an enumeration of said list.
                   // So we add the doomed entry to a list to be removed later.
                   EntriesToRemove.Add(e);
                 }
               }
               
               // actually remove the doomed entries. 
               foreach (ZipEntry zombie in EntriesToRemove)
                 zip.RemoveEntry(zombie);
               
               zip.Comment= String.Format("This zip archive was updated at {0}.", 
                                          System.DateTime.Now.ToString("G"));
               zip.Save();
             }
             </code>
             
             <code lang="VB">
               Dim ZipFileToRead As String = "c:\foo.zip"
               Dim Threshold As New DateTime(2007, 12, 31)
               Using zip As ZipFile = New ZipFile(ZipFileToRead)
                   Dim EntriesToRemove As New System.Collections.Generic.List(Of ZipEntry)
                   Dim e As ZipEntry
                   For Each e In zip
                       If (e.LastModified &lt; Threshold) Then
                           ' We cannot remove the entry from the list, within the context of 
                           ' an enumeration of said list.
                           ' So we add the doomed entry to a list to be removed later.
                           EntriesToRemove.Add(e)
                       End If
                   Next
               
                   ' actually remove the doomed entries. 
                   Dim zombie As ZipEntry
                   For Each zombie In EntriesToRemove
                       zip.RemoveEntry(zombie)
                   Next
                   zip.Comment = String.Format("This zip archive was updated at {0}.", DateTime.Now.ToString("G"))
                   zip.Save
               End Using
             </code>
             </example>
             
             <param name="entry">
             The ZipEntry to remove from the zip. 
             </param>
             
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.RemoveEntry(System.String)">
             <summary>
             Removes the ZipEntry with the given filename from the zip archive.  
             </summary>
             
             <remarks>
             <para>
             After calling <c>RemoveEntry</c>, the application must call <c>Save</c> to make the changes permanent.  
             </para>
            
             </remarks>
            
             <exception cref="T:System.InvalidOperationException">
             Thrown if the ZipFile is not updatable. 
             </exception>
            
             <exception cref="T:System.ArgumentException">
             Thrown if a ZipEntry with the specified filename does not exist in the ZipFile.
             </exception>
            
             <example>
             This example shows one way to remove an entry with a given filename from an 
             existing zip archive.
             <code>
             String ZipFileToRead= "PackedDocuments.zip";
             string Candidate = "DatedMaterial.xps";
             using (ZipFile zip = new ZipFile(ZipFileToRead))
             {
               if (zip.EntryFilenames.Contains(Candidate))
               {
                 zip.RemoveEntry(Candidate);
                 zip.Comment= String.Format("The file '{0}' has been removed from this archive.", 
                                            Candidate);
                 zip.Save();
               }
             }
             </code>
             <code lang="VB">
               Dim ZipFileToRead As String = "PackedDocuments.zip"
               Dim Candidate As String = "DatedMaterial.xps"
               Using zip As ZipFile = New ZipFile(ZipFileToRead)
                   If zip.EntryFilenames.Contains(Candidate) Then
                       zip.RemoveEntry(Candidate)
                       zip.Comment = String.Format("The file '{0}' has been removed from this archive.", Candidate)
                       zip.Save
                   End If
               End Using
             </code>
             </example>
             
             <param name="fileName">
             The name of the file, including any directory path, to remove from the zip. 
             The filename match is not case-sensitive by default; you can use the
             <c>CaseSensitiveRetrieval</c> property to change this behavior. The
             pathname can use forward-slashes or backward slashes.
             </param>
             
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.Finalize">
            <summary>
            This is the class Destructor, which gets called implicitly when the instance is destroyed.  
            Because the ZipFile type implements IDisposable, this method calls Dispose(false).  
            </summary>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.Dispose">
            <summary>
            Handles closing of the read and write streams associated
            to the ZipFile, if necessary.  The Dispose() method is generally 
            employed implicitly, via a using() {} statement. 
            </summary>
            <example>
            <code>
            using (ZipFile zip = ZipFile.Read(zipfile))
            {
              foreach (ZipEntry e in zip)
              {
                if (WantThisEntry(e.FileName)) 
                  zip.Extract(e.FileName, Console.OpenStandardOutput());
              }
            } // Dispose() is called implicitly here.
            </code>
            </example>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipFile.Dispose(System.Boolean)">
            <summary>
            The Dispose() method.  It disposes any managed resources, 
            if the flag is set, then marks the instance disposed.
            This method is typically not called from application code.
            </summary>
            <param name="disposeManagedResources">indicates whether the method should dispose streams or not.</param>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipFile.Name">
            <summary>
            This read-only property specifies the name of the zipfile to read or write. It is 
            set when the instance of the ZipFile type is created. When instantiating a ZipFile 
            to read from or write to a stream, the Name property remains null.
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipFile.Comment">
             <summary>
             A comment attached to the zip archive.
             </summary>
            
             <remarks>
             <para>
             This property is read/write for the zipfile. It allows the application to
             specify a comment for the zipfile, or read the comment for the zipfile. 
             If setting the comment, changes are only made permanent when you call a
             <c>Save()</c> method.
             </para>
             <para>
             According to the zip spec, the comment is not encrypted, even if there is a password
             set on the zip archive. 
             </para>
             </remarks>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipFile.TrimVolumeFromFullyQualifiedPaths">
             <summary>
             When this is set, any volume name (eg C:) is trimmed 
             from fully-qualified pathnames on any ZipEntry, before writing the 
             ZipEntry into the ZipFile. 
             </summary>
            
             <remarks>
             <para>
             The default value is true. This setting must be true to allow 
             Windows Explorer to read the zip archives properly. It's also required to be 
             true if you want to read the generated zip files on any other non-Windows OS. 
             </para>
             
             <para>
             The property is included for backwards compatibility only.  You'll 
             almost never need or want to set this to false.
             </para>
             </remarks>
            
        </member>
        <member name="P:Ionic.Utils.Zip.ZipFile.Verbose">
            <summary>
            Indicates whether verbose output is sent to the StatusMessageWriter
            during <c>AddXxx()</c> and <c>ReadXxx()</c> operations. 
            </summary>
            <remarks>
            This is a synthetic property.  It returns true if the <see cref="P:Ionic.Utils.Zip.ZipFile.StatusMessageTextWriter">StatusMessageTextWriter</see> is non-null. 
            </remarks>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipFile.CaseSensitiveRetrieval">
            <summary>
            Indicates whether to perform case-sensitive matching on the
            filename when retrieving entries in the zipfile via the string-based indexer. 
            The default value is false, which means DON'T do case-sensitive matching.
            It really makes sense to set this to TRUE only if you are not running on
            Windows, which has case-insensitive filenames.  In most cases you should just 
            leave this property alone. 
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipFile.UseUnicode">
            <summary>
            Indicates whether to encode entry filenames and entry comments using Unicode 
            (UTF-8) according to the PKWare specification, for those filenames and comments
            that cannot be encoded in the ASCII character set.
            </summary>
            <remarks>
            <para>
            The PKWare specification provides for encoding in either the IBM437 code page, or in UTF-8. 
            This flag selects the encoding according to that specification. 
            By default, this flag is false, and filenames and comments are encoded 
            into the zip file in the IBM437 codepage. 
            Setting this flag to true will specify that
            filenames and comments are encoded with UTF-8. 
            </para>
            <para>
            Zip files created with strict adherence to the PKWare specification
            with respect to UTF-8 encoding can contain entries with filenames containing
            any combination of Unicode characters, including the full 
            range of characters from Chinese, Latin, Hebrew, Greek, Cyrillic, and many 
            other alphabets. 
            However, because the UTF-8 portion of the PKWare specification is not broadly
            supported by other zip libraries and utilities, such zip files may not
            be readable by your favorite zip tool or archiver. In other words, interoperability
            will suffer if you set this flag to true. 
            </para>
            <para>
            In particular, Zip files created with strict adherence to the PKWare 
            specification with respect to UTF-8 encoding will not work well with 
            Explorer in Windows XP or Windows Vista, because Vista compressed folders 
            do not support UTF-8 in zip files.  Vista can read the zip files, but shows
            the filenames incorrectly.  Unpacking from Windows Vista Explorer will result in filenames
            that have rubbish characters in place of the high-order UTF-8 bytes.
            </para>
            <para>
            Also, zip files that use UTF-8 encoding will not work well 
            with Java applications that use the java.util.zip classes, as of 
            v5.0 of the Java runtime. The Java runtime does not correctly 
            implement the PKWare specification in this regard.
            </para>
            <para>
            As a result, we have the curious situation that "correct" 
            behavior by the DotNetZip library during zip creation will result 
            in zip files that are not able to be read by various other tools.
            </para>
            <para>
            The DotNetZip library can read and write zip files 
            with UTF8-encoded entries, according to the PKware spec.  If you use DotNetZip for both 
            creating and reading the zip file, and you use UTF-8, there will be no loss of information 
            in the filenames. For example, using a self-extractor created by this
            library will allow you to unpack files correctly with no loss of 
            information in the filenames. 
            </para>
            <para>
            Encoding filenames and comments using the IBM437 codepage, the default
            behavior, will cause loss of information on some filenames that contain 
            super-ASCII characters, but the resulting zipfile will
            be more interoperable with other utilities. As an example of the 
            loss of information, the o-tilde character will be down-coded to plain o. 
            Likewise, the O with a stroke through it, used in Danish and Norwegian,
            will be down-coded to plain o. Chinese characters cannot be represented
            in codepage IBM437; when using the default encoding, Chinese characters in 
            filenames will be represented as ?.  
            </para>
            <para>
            The loss of information associated to the use of the IBM437 encoding can 
            lead to runtime errors. For example, using 
            IBM437, any sequence of 4 Chinese characters will be encoded as 
            ????.  If your application creates a ZipFile, then adds two files, each with 
            names of four Chinese characters each, this will result in a duplicate 
            filename exception.  In the case where you add a single file with a name 
            containing four Chinese characters, attempting to unzip the file to the Windows
            filesystem will lead to an exception, because ? is not a legal character in a filename.         
            These are just a few examples of the problems associated to loss of information.
            </para>
            <para>
            This flag has no effect or relation to the encoding of the content within the 
            entries in the zip file.  
            </para>
            <para>
            Rather than specify the encoding in a binary fashion using this flag, an application
            can specify an arbitrary encoding via the <c>Encoding</c>property.  Setting 
            the encoding explicitly when creating zip archives will result in non-compliant 
            zip files that, curiously, are fairly interoperable.  The challenge is, the PKWare specification
            does not provide for a way to specify an arbitrary code page for an entry.  Therefore 
            if you set the encoding explicitly when creating a zip archive, you must take care upon 
            reading the zip archive to use the same code page.  If you get it wrong, the behavior is 
            undefined and may result in incorrect filenames, exceptions, and acne.  
            </para>
            <seealso cref="P:Ionic.Utils.Zip.ZipFile.Encoding">Encoding</seealso>
            </remarks>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipFile.Encoding">
            <summary>
            The text encoding to use when writing new entries to the ZipFile.  
            </summary>
            
            <remarks>
            <para>
            In its AppNote.txt document, PKWare describes how to specify in the zip entry header
            that a filename or comment containing non-ANSI characters is encoded with UTF-8.  But, some 
            archivers do not follow the specification, and instead encode super-ANSI characters using the 
            system default code page.  For example, WinRAR when run on a machine in Shanghai may encode 
            filenames with the Chinese code page.  This behavior is contrary to the Zip specification, but it 
            occurs anyway.
            </para>
            <para>
            When using DotNetZip to write zip archives that will be read by one of these other archivers, 
            set this property to specify the code page to use when encoding filenames and comments into the zip file.
            </para>
            <para>
            The default encoding is codepage IBM437.  Be aware that a zip file created after you've explicitly 
            specified the code page will not be compliant to the PKWare specification, and may not be readable 
            by compliant archivers.  On the other hand, many (most?) archivers are non-compliant and can read zip files 
            created in arbitrary code pages.  The trick is to use the proper codepage when reading the zip.
            </para>
            <para>
            When using an arbitrary, non-UTF8 code page for encoding, there is no standard way for the 
            creator application - whether DotNetZip, WinRar, or something else - to specify in the zip file 
            which codepage has been used. As a result, readers of zip files are not
            able to inspect the zip file and determine the codepage that was used for the entries contained within it. 
            It is left to the application to determine the necessary codepage when reading zipfiles encoded this way.  
            If you use an incorrect codepage when reading a zipfile, you can get entries with filenames
            that are either incorrect or not legal in Windows. Extracting entries with illegal characters 
            in the filenames will lead to exceptions. Caveat Emptor.
            </para>
            </remarks>
            
            <seealso cref="F:Ionic.Utils.Zip.ZipFile.DefaultEncoding">DefaultEncoding</seealso>.
        </member>
        <member name="P:Ionic.Utils.Zip.ZipFile.StatusMessageTextWriter">
             <summary>
             Gets or sets the <c>TextWriter</c> to which status messages are delivered 
             for the instance. If the TextWriter is set to a non-null value, then 
             verbose output is sent to the <c>TextWriter</c> during <c>Add</c><c>, Read</c><c>, Save</c> and
             <c>Extract</c> operations.  
             </summary>
            
             <example>
             <para>
             In this example, a console application instantiates a ZipFile, then sets
             the StatusMessageTextWriter to Console.Out.  At that point, all verbose
             status messages for that ZipFile are sent to the console. 
             </para>
            
             <code lang="C#">
             using (ZipFile zip= new ZipFile(FilePath))
             {
               zip.StatusMessageTextWriter= System.Console.Out;
               // messages are sent to the console during extraction
               zip.ExtractAll();
             }
             </code>
            
             <code lang="VB">
             Using zip As new ZipFile(FilePath)
               zip.StatusMessageTextWriter= System.Console.Out
               'Status Messages will be sent to the console during extraction
               zip.ExtractAll()
             End Using
             </code>
             </example>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipFile.ForceNoCompression">
             <summary>
             Gets or sets the flag that indicates whether the ZipFile should use
             compression for subsequently added entries in the ZipFile instance.
             </summary>
            
             <remarks>
             <para> 
             When saving an entry into a zip archive, the DotNetZip first compresses
             the file, then compares the size of the pre-compressed data with the size of the
             post-compressed data. For files that are already compressed, like MP3's or JPGs,
             the deflate algorithm can actually expand the size of the data.  In this case,
             the DotNetZip library uses the pre-compressed data and simply stores the file
             data into the archive. 
             </para> 
            
             <para>
             The DotNetZip library does this optimization automatically.  To avoid the
             unnecessary processing and comparison, the application can explicitly request
             that Compression not be used, by setting this flag.  The default value is false.
             </para> 
            
             <para>
             Do not construe setting this flag to false as "Force Compression".  Setting it
             to false merely does NOT force No compression.  Think about it a little bit:
             There's a difference.  If you want to force the use fo deflate algorithm when
             storing each entry into the zip archive, define a <see cref="P:Ionic.Utils.Zip.ZipFile.WillReadTwiceOnInflation"/> callback, which always returns false.  This is
             probably the wrong thing to do, but you could do it.  Forcing the use of the
             Deflate algorithm when storing an entry does not guarantee that the data size
             will get smaller. It could increase, as described above.  But if you want to be
             pig-headed about it, go ahead.
             </para>
            
             <para>
             Changes to this flag apply to all entries subsequently added to the archive. 
             The application can also set the CompressionMethod
             property on each ZipEntry, for more granular control of this capability.
             </para>
            
             </remarks>
            
             <seealso cref="P:Ionic.Utils.Zip.ZipEntry.CompressionMethod"/>
            
             <example>
             This example shows how to specify that Compression will not be used when adding files 
             to the zip archive. None of the files added to the archive in this way will use
             compression.
             <code>
             using (ZipFile zip = new ZipFile(ZipFileToCreate))
             {
               zip.ForceNoCompression = true;
               zip.AddDirectory(@"c:\temp\Foo");
               zip.Comment = "All files in this archive will be uncompressed.";
               zip.Save();
             }
             </code>
            
             <code lang="VB">
             Using zip As New ZipFile(ZipFileToCreate)
               zip.ForceNoCompression = true
               zip.AddDirectory("c:\temp\Foo")
               zip.Comment = "All files in this archive will be uncompressed."
               zip.Save()
             End Using
             </code>
            
             </example>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipFile.TempFileFolder">
             <summary>
             Gets or sets the name for the folder to store the temporary file
             this library writes when saving the zip archive. 
             </summary>
            
             <remarks>
             The calling application should have write and delete rights on that folder.  By
             default, the temp file folder is the directory referred to by the TEMP
             environment variable.  If that variable is not set, this value defaults to the
             current working directory.  But for some scenarios, such as ASP.NET
             applications, the application may wish to explicitly override this,
             with this public property. This property is used only when calling one of the
             <c>Save()</c> methods, or the <c>SaveSelfExtractor()</c> method.
             </remarks>
            
             <exception cref="T:System.IO.FileNotFoundException">
             Thrown upon setting the property if the directory does not exist. 
             </exception>
            
        </member>
        <member name="P:Ionic.Utils.Zip.ZipFile.Password">
             <summary>
             Sets the password to be used for any entry subsequently added 
             to the ZipFile, using one of the AddFile, AddDirectory, or AddItem methods; 
             or any entry subsequently extracted from the ZipFile using one of the Extract methods on the ZipFile class.  
             This password is applied to the entries, not
             to the zip archive itself. 
             </summary>
             <remarks>
             
             <para>
             Though the password is set on the ZipFile object, the password
             actually does not apply to the archive as a whole.  Instead, it
             applies to individual entries that are added to the archive, from
             that point in time onward.  The "directory" of the archive - in other
             words the list of files - is not encrypted with the password, The
             list of filenames in the archive is in clear text.  but the contents
             of the individual files are encrypted.
             </para>
             
             <para>
             If you set the password on the zip archive, and then add a set of files to the 
             archive, then each entry is encrypted with that password.  You may also want 
             to change the password between adding different entries. If you set the 
             password, add an entry, then set the password to null, and add another entry,
             the first entry is encrypted and the second is not.  Furshtay?
             </para>
             
             <para>
             If you read in an existing ZipFile, then set the Password property, then call
             one of the ZipFile.Extract() overloads, the entry is extracted using the Password that is 
             specified on the ZipFile instance. If you have not set the Password property, then
             the password is null, and the entry is extracted with no password.
             </para>
             
             </remarks>
            
             <example>
             <para>
             In this example, three files are added to a Zip archive. The ReadMe.txt file
             will be placed in the root of the archive, and will not be encrypted. 
             The .png file will be included into the zip, encrypted with the "123456!" password.
             The pdf file will be included, encrypted with "!Secret1" as the password.
             </para>
             <code>
                try
                {
                  using (ZipFile zip = new ZipFile("test3.zip",System.Console.Out))
                  {
                    zip.AddFile("ReadMe.txt");
                    zip.Password= "123456!";
                    zip.AddFile("7440-N49th.png");
                    zip.Password= "!Secret1";
                    zip.AddFile("2005_Annual_Report.pdf");
            
                    zip.Save();
                  }
                }
                catch (System.Exception ex1)
                {
                  System.Console.Error.WriteLine("exception: {0}", ex1);
                }
             </code>
            
             <code lang="VB">
              Try 
                Using zip As New ZipFile("test2.zip", System.Console.Out)
                  zip.AddFile("c:\datafiles\ReadMe.txt", "")
                  zip.Password = "123456!"
                  zip.AddFile("c:\photos\personal\7440-N49th.png", "images")
                  zip.Password= "!Secret1";
                  zip.AddFile("c:\Desktop\2005_Annual_Report.pdf", "files\documents")
                  zip.Save
                End Using
              Catch ex1 As System.Exception
                System.Console.Error.WriteLine("exception: {0}", ex1)
              End Try
             </code>
            
             </example>
             
        </member>
        <member name="P:Ionic.Utils.Zip.ZipFile.WillReadTwiceOnInflation">
             <summary>
             A callback that allows the application to specify whether multiple reads of the
             stream should be performed, in the case that a compression operation actually
             inflates the size of the file data.  
             </summary>
            
             <remarks>
             <para>
             In some cases, applying the Deflate compression algorithm in DeflateStream can
             result an increase in the size of the data.  This "inflation" can happen with
             previously compressed files, such as a zip, jpg, png, mp3, and so on.  In a few
             tests, inflation on zip files can be as large as 60%!  Inflation can also happen
             with very small files.  In these cases, by default, the DotNetZip library
             discards the compressed bytes, and stores the uncompressed file data into the
             zip archive.  This is an optimization where smaller size is preferred over
             longer run times.
             </para>
            
             <para>
             The application can specify that compression is not even tried, by setting the
             ForceNoCompression flag.  In this case, the compress-and-check-sizes process as
             decribed above, is not done.
             </para>
            
             <para>
             In some cases, neither choice is optimal.  The application wants compression,
             but in some cases also wants to avoid reading the stream more than once.  This
             may happen when the stream is very large, or when the read is very expensive, or
             when the difference between the compressed and uncompressed sizes is not
             significant.
             </para>
            
             <para>
             To satisfy these applications, this delegate allows the DotNetZip library to ask
             the application to for approval for re-reading the stream, in the case where
             inflation occurs.  The callback is invoked only in the case of inflation; that
             is to say when the uncompressed stream is smaller than the compressed stream.
             </para>
            
             <para>
             As with other properties (like Password and ForceNoCompression), setting the
             corresponding delegate on the ZipFile class itself will set it on all ZipEntry
             items that are subsequently added to the ZipFile instance.
             </para>
            
             </remarks>
             <example>
             <para>
             In this example, the application callback checks to see if the difference
             between the compressed and uncompressed data is greater than 25%.  If it is,
             then the callback returns true, and the application tells the library to re-read
             the stream.  If not, then the callback returns false, and the library just keeps
             the "inflated" file data.
             </para>
            
             <code>
            
             public bool ReadTwiceCallback(int uncompressed, int compressed, string filename)
             {
                 return ((uncompressed * 1.0/compressed) &gt; 1.25);
             }
             
             public void CreateTheZip()
             {
                 using (ZipFile zip = new ZipFile())
                 {
                     zip2.WillReadTwiceOnInflation = ReadTwiceCallback;
                     zip2.AddFile(filename1);
                     zip2.AddFile(filename2);
                     zip2.Save(ZipFileToCreate);
                 }
             }
             </code>
             </example>
             <seealso cref="T:Ionic.Utils.Zip.ReReadApprovalCallback"/>
             <seealso cref="P:Ionic.Utils.Zip.ZipEntry.WillReadTwiceOnInflation"/>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipFile.LibraryVersion">
            <summary>
            Returns the version number on the assembly.
            </summary>
            <remarks>
            This property is exposed as a convenience.  Callers
            could also get the version value by retrieving  GetName().Version 
            on the System.Reflection.Assembly object pointing to the
            DotNetZip assembly. But sometimes it is not clear which
            assembly is being loaded.  This property makes it clear. 
            </remarks>
        </member>
        <member name="E:Ionic.Utils.Zip.ZipFile.SaveStarted">
            <summary>
            Fired when the save starts.
            </summary>
        </member>
        <member name="E:Ionic.Utils.Zip.ZipFile.SaveProgress">
             <summary>
             Fired after each entry has been written to the archive.
             </summary>
             <example>
             <code lang="C#">
             public static void SaveProgress(object sender, SaveProgressEventArgs e)
             {
               Console.WriteLine("{0} ({1}/{2})", e.NameOfLatestEntry, e.EntriesSaved, e.EntriesTotal);
             }
             
             public static ZipUp(string targetZip, string directory)
             {
               using (var zip = new ZipFile()) {
                 zip.SaveProgress += SaveProgress; 
                 zip.AddDirectory(directory);
                 zip.Save(targetZip);
               }
             }
            
             </code>
             <code lang="VB">
             Public Sub ZipUp(ByVal targetZip As String, ByVal directory As String)
             	Try 
             	    Using zip As ZipFile = New ZipFile
             		AddHandler zip.SaveProgress, AddressOf MySaveProgress
             		zip.AddDirectory(directory)
             		zip.Save(targetZip)
             	    End Using
             	Catch ex1 As Exception
             	    Console.Error.WriteLine(("exception: " &amp; ex1.ToString))
             	End Try
             End Sub
             
             Public Sub MySaveProgress(ByVal sender As Object, ByVal e As SaveProgressEventArgs)
                 Console.WriteLine("{0} ({1}/{2})", e.NameOfLatestEntry, e.EntriesSaved, e.EntriesTotal)
             End Sub
             </code>
             </example>
        </member>
        <member name="E:Ionic.Utils.Zip.ZipFile.SaveCompleted">
            <summary>
            Fired after the save completes.
            </summary>
        </member>
        <member name="E:Ionic.Utils.Zip.ZipFile.ExtractStarted">
            <summary>
            Fired when the ExtractAll starts, before the first entry is extracted.
            </summary>
        </member>
        <member name="E:Ionic.Utils.Zip.ZipFile.ExtractProgress">
             <summary>
             Fired after each entry has been extracted from the archive, during the 
             execution of the ExtractAll method.
             </summary>
             <example>
             <code>
             public static void ExtractProgress(object sender, ExtractProgressEventArgs e)
             {
               Console.WriteLine("{0} ({1}/{2})", e.NameOfLatestEntry, e.EntriesExtractd, e.EntriesTotal);
             }
             
             public static ExtractZip(string zipToExtract, string directory)
             {
               using (var zip = new ZipFile(zipToExtract)) {
                 zip.ExtractProgress += ExtractProgress; 
                 zip.ExtractAll(directory, true);
               }
             }
            
             </code>
             </example>
        </member>
        <member name="E:Ionic.Utils.Zip.ZipFile.ExtractCompleted">
            <summary>
            Fired after the extract completes.
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipFile.Item(System.Int32)">
             <summary>
             This is an integer indexer into the Zip archive.  
             </summary>
             
             <remarks>
             <para>
             This property is read-write. But don't get too excited: When setting the value, the
             only legal value is null. If you assign a non-null value
             (non Nothing in VB), the setter will throw an exception.
             </para>
             <para>
             Setting the value to null is equivalent to calling <c>ZipFile.RemoveEntry</c> 
             with the filename for the given entry.
             </para>
             </remarks>
             
             <exception cref="T:System.ArgumentException">
             Thrown if the caller attempts to assign a non-null value to the indexer, 
             or if the caller uses an out-of-range index value.
             </exception>
            
             <param name="ix">
             The index value.
             </param>
             
             <returns>
             The ZipEntry within the Zip archive at the specified index. If the 
             entry does not exist in the archive, this indexer throws.
             </returns>
             
        </member>
        <member name="P:Ionic.Utils.Zip.ZipFile.Item(System.String)">
             <summary>
             This is a name-based indexer into the Zip archive.  
             </summary>
             
             <remarks>
             <para>
             Retrieval by the string-based indexer is done on a case-insensitive basis, 
             by default.  Set the <see cref="P:Ionic.Utils.Zip.ZipFile.CaseSensitiveRetrieval"/> property to use case-sensitive 
             comparisons. 
             </para>
             <para>
             This property is read-write. When setting the value, the
             only legal value is null. If you assign a non-null value
             (non Nothing in VB), the setter will throw an exception.
             </para>
             <para>
             Setting the value to null is equivalent to calling <c>ZipFile.RemoveEntry</c> 
             with the filename.
             </para>
             </remarks>
             
             <example>
             This example extracts only the entries in a zip file that are .txt files.
             <code>
             using (ZipFile zip = ZipFile.Read("PackedDocuments.zip"))
             {
               foreach (string s1 in zip.EntryFilenames)
               {
                 if (s1.EndsWith(".txt"))
                   zip[s1].Extract("textfiles");
               }
             }
             </code>
             <code lang="VB">
               Using zip As ZipFile = ZipFile.Read("PackedDocuments.zip")
                   Dim s1 As String
                   For Each s1 In zip.EntryFilenames
                       If s1.EndsWith(".txt") Then
                           zip(s1).Extract("textfiles")
                       End If
                   Next
               End Using
             </code>
             </example>
             <seealso cref="M:Ionic.Utils.Zip.ZipFile.RemoveEntry(System.String)"/>
            
             <exception cref="T:System.ArgumentException">
             Thrown if the caller attempts to assign a non-null value to the indexer.
             </exception>
            
             <param name="fileName">
             The name of the file, including any directory path, to retrieve from the zip. 
             The filename match is not case-sensitive by default; you can use the
             <c>CaseSensitiveRetrieval</c> property to change this behavior. The
             pathname can use forward-slashes or backward slashes.
             </param>
             
             <returns>
             The ZipEntry within the Zip archive, given by the specified filename. If the named
             entry does not exist in the archive, this indexer returns null.
             </returns>
             
        </member>
        <member name="P:Ionic.Utils.Zip.ZipFile.EntryFileNames">
             <summary>
             The list of filenames for the entries contained within the zip archive.  The 
             filenames use forward slashes in pathnames. 
             </summary>
            
             <seealso cref="P:Ionic.Utils.Zip.ZipFile.Item(System.String)"/>
            
             <example>
             This example shows one way to test if a filename is already contained within 
             a zip archive.
             <code>
             String ZipFileToRead= "PackedDocuments.zip";
             string Candidate = "DatedMaterial.xps";
             using (ZipFile zip = new ZipFile(ZipFileToRead))
             {
               if (zip.EntryFilenames.Contains(Candidate))
                 Console.WriteLine("The file '{0}' exists in the zip archive '{1}'",
                                   Candidate,
                                   ZipFileName);
               else
                 Console.WriteLine("The file, '{0}', does not exist in the zip archive '{1}'",
                                   Candidate,
                                   ZipFileName);
               Console.WriteLine();
             }
             </code>
             <code lang="VB">
               Dim ZipFileToRead As String = "PackedDocuments.zip"
               Dim Candidate As String = "DatedMaterial.xps"
               Using zip As New ZipFile(ZipFileToRead)
                   If zip.EntryFilenames.Contains(Candidate) Then
                       Console.WriteLine("The file '{0}' exists in the zip archive '{1}'", _
                                   Candidate, _
                                   ZipFileName)
                   Else
                     Console.WriteLine("The file, '{0}', does not exist in the zip archive '{1}'", _
                                   Candidate, _
                                   ZipFileName)
                   End If
                   Console.WriteLine
               End Using
             </code>
             </example>
            
             <returns>
             The list of strings for the filenames contained within the Zip archive.
             </returns>
             
        </member>
        <member name="T:Ionic.Utils.Zip.ZipDirEntry">
            <summary>
            This class models an entry in the directory contained within the zip file.
            The class is generally not used from within application code, though it is
            used by the ZipFile class.
            </summary>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipDirEntry.Read(System.IO.Stream,System.Text.Encoding)">
            <summary>
            Reads one entry from the zip directory structure in the zip file. 
            </summary>
            <param name="s">the stream from which to read.</param>
            <param name="expectedEncoding">
            The text encoding to use if the entry is not marked UTF-8.
            </param>
            <returns>the entry read from the archive.</returns>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipDirEntry.IsNotValidSig(System.Int32)">
            <summary>
            Returns true if the passed-in value is a valid signature for a ZipDirEntry. 
            </summary>
            <param name="signature">the candidate 4-byte signature value.</param>
            <returns>true, if the signature is valid according to the PKWare spec.</returns>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipDirEntry.FileName">
            <summary>
            The filename of the file represented by the given entry.
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipDirEntry.Comment">
            <summary>
            Any comment associated to the given entry. Comments are generally optional.
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipDirEntry.IsDirectory">
            <summary>
            True if the referenced entry is a directory.  
            </summary>
        </member>
        <member name="T:Ionic.Utils.Zip.BadPasswordException">
            <summary>
            Issued when an <c>ZipEntry.ExtractWithPassword()</c> method is invoked
            with an incorrect password.
            </summary>
        </member>
        <member name="T:Ionic.Utils.Zip.ZipException">
            <summary>
            Base class for all exceptions defined by and throw by the Zip library.
            </summary>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipException.#ctor">
            <summary>
            Default ctor.
            </summary>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipException.#ctor(System.String)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipException.#ctor(System.String,System.Exception)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
            <param name="innerException">The innerException for this exception.</param>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="serializationInfo">The serialization info for the exception.</param>
            <param name="streamingContext">The streaming context from which to deserialize.</param>
        </member>
        <member name="M:Ionic.Utils.Zip.BadPasswordException.#ctor">
            <summary>
            Default ctor.
            </summary>
        </member>
        <member name="M:Ionic.Utils.Zip.BadPasswordException.#ctor(System.String)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
        </member>
        <member name="M:Ionic.Utils.Zip.BadPasswordException.#ctor(System.String,System.Exception)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
            <param name="innerException">The innerException for this exception.</param>
        </member>
        <member name="M:Ionic.Utils.Zip.BadPasswordException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="serializationInfo">The serialization info for the exception.</param>
            <param name="streamingContext">The streaming context from which to deserialize.</param>
        </member>
        <member name="T:Ionic.Utils.Zip.BadReadException">
            <summary>
            Indicates that a read was attempted on a stream, and bad or incomplete data was
            received.  
            </summary>
        </member>
        <member name="M:Ionic.Utils.Zip.BadReadException.#ctor">
            <summary>
            Default ctor.
            </summary>
        </member>
        <member name="M:Ionic.Utils.Zip.BadReadException.#ctor(System.String)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
        </member>
        <member name="M:Ionic.Utils.Zip.BadReadException.#ctor(System.String,System.Exception)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
            <param name="innerException">The innerException for this exception.</param>
        </member>
        <member name="M:Ionic.Utils.Zip.BadReadException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="serializationInfo">The serialization info for the exception.</param>
            <param name="streamingContext">The streaming context from which to deserialize.</param>
        </member>
        <member name="T:Ionic.Utils.Zip.BadCrcException">
            <summary>
            Issued when an CRC check fails upon extracting an entry from a zip archive.
            </summary>
        </member>
        <member name="M:Ionic.Utils.Zip.BadCrcException.#ctor">
            <summary>
            Default ctor.
            </summary>
        </member>
        <member name="M:Ionic.Utils.Zip.BadCrcException.#ctor(System.String)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
        </member>
        <member name="M:Ionic.Utils.Zip.BadCrcException.#ctor(System.String,System.Exception)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
            <param name="innerException">The innerException for this exception.</param>
        </member>
        <member name="M:Ionic.Utils.Zip.BadCrcException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="serializationInfo">The serialization info for the exception.</param>
            <param name="streamingContext">The streaming context from which to deserialize.</param>
        </member>
        <member name="T:Ionic.Utils.Zip.SfxGenerationException">
            <summary>
            Issued when errors occur saving a self-extracting archive.
            </summary>
        </member>
        <member name="M:Ionic.Utils.Zip.SfxGenerationException.#ctor">
            <summary>
            Default ctor.
            </summary>
        </member>
        <member name="M:Ionic.Utils.Zip.SfxGenerationException.#ctor(System.String)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
        </member>
        <member name="M:Ionic.Utils.Zip.SfxGenerationException.#ctor(System.String,System.Exception)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
            <param name="innerException">The innerException for this exception.</param>
        </member>
        <member name="M:Ionic.Utils.Zip.SfxGenerationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="serializationInfo">The serialization info for the exception.</param>
            <param name="streamingContext">The streaming context from which to deserialize.</param>
        </member>
        <member name="T:Ionic.Utils.Zip.BadStateException">
            <summary>
            Indicates that an operation was attempted on a ZipFile which was not possible
            given the state of the instance. For example, if you call <c>Save()</c> on a ZipFile 
            which has no filename set, you can get this exception. 
            </summary>
        </member>
        <member name="M:Ionic.Utils.Zip.BadStateException.#ctor">
            <summary>
            Default ctor.
            </summary>
        </member>
        <member name="M:Ionic.Utils.Zip.BadStateException.#ctor(System.String)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
        </member>
        <member name="M:Ionic.Utils.Zip.BadStateException.#ctor(System.String,System.Exception)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
            <param name="innerException">The innerException for this exception.</param>
        </member>
        <member name="M:Ionic.Utils.Zip.BadStateException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="serializationInfo">The serialization info for the exception.</param>
            <param name="streamingContext">The streaming context from which to deserialize.</param>
        </member>
        <member name="T:Ionic.Utils.Zip.SharedUtilities">
            <summary>
            Collects general purpose utility methods.
            </summary>
        </member>
        <member name="M:Ionic.Utils.Zip.SharedUtilities.#ctor">
            private null constructor
        </member>
        <member name="M:Ionic.Utils.Zip.SharedUtilities.RoundToEvenSecond(System.DateTime)">
             <summary>
             Round the given DateTime value to an even second value.  
             </summary>
            
             <remarks>
             <para>
             Round up in the case of an odd second value.  The rounding does not consider fractional seconds.
             </para>
             <para>
             This is useful because the Zip spec allows storage of time only to the nearest even second.
             So if you want to compare the time of an entry in the archive with it's actual time in the filesystem, you 
             need to round the actual filesystem time, or use a 2-second threshold for the  comparison. 
             </para>
             <para>
             This is most nautrally an extension method for the DateTime class but this library is 
             built for .NET 2.0, not for .NET 3.5;  This means extension methods are a no-no.  
             </para>
             </remarks>
             <param name="source">The DateTime value to round</param>
             <returns>The ruonded DateTime value</returns>
        </member>
        <member name="M:Ionic.Utils.Zip.SharedUtilities.TrimVolumeAndSwapSlashes(System.String)">
            <summary>
            Utility routine for transforming path names. 
            </summary>
            <param name="pathName">source path.</param>
            <returns>transformed path</returns>
        </member>
        <member name="M:Ionic.Utils.Zip.SharedUtilities.FindSignature(System.IO.Stream,System.Int32)">
            <summary>
            Finds a signature in the zip stream. This is useful for finding 
            the end of a zip entry, for example. 
            </summary>
            <param name="stream"></param>
            <param name="SignatureToFind"></param>
            <returns></returns>
        </member>
        <member name="M:Ionic.Utils.Zip.SharedUtilities.StringToMemoryStream(System.String)">
            <summary>
            Creates a <c>MemoryStream</c> for the given string. This is used internally by Library, specifically by 
            the ZipFile.AddStringAsFile() method.   But it may be useful in other scenarios. 
            </summary>
            <param name="s">The string to use as input for the MemoryStream</param>
            <returns>the MemoryStream. Reading the stream will give you the content of the String.</returns>
        </member>
        <member name="T:Ionic.Utils.Zip.CountingStream">
            <summary> 
            A Stream wrapper, used for bookkeeping on input or output
            streams.  In some cases, it is not possible to get the Position
            of a stream, let's say, on a write-only output stream like
            ASP.NET's Response.Output, or on a different write-only stream
            provided as the destination for the zip by the application.
            In this case, we can use this counting stream to count the bytes
            read or written.
            </summary>
        </member>
        <member name="M:Ionic.Utils.Zip.CountingStream.#ctor(System.IO.Stream)">
            <summary>
            The  constructor.
            </summary>
            <param name="s">The underlying stream</param>
        </member>
        <member name="T:Ionic.Utils.Zip.CRC32">
            <summary>
            Calculates a 32bit Cyclic Redundancy Checksum (CRC) using the
            same polynomial used by Zip. This type ie generally not used directly
            by applications wishing to create, read, or manipulate zip archive files.
            </summary>
        </member>
        <member name="M:Ionic.Utils.Zip.CRC32.GetCrc32(System.IO.Stream)">
            <summary>
            Returns the CRC32 for the specified stream.
            </summary>
            <param name="input">The stream over which to calculate the CRC32</param>
            <returns>the CRC32 calculation</returns>
        </member>
        <member name="M:Ionic.Utils.Zip.CRC32.GetCrc32AndCopy(System.IO.Stream,System.IO.Stream)">
            <summary>
            Returns the CRC32 for the specified stream, and writes the input into the output stream.
            </summary>
            <param name="input">The stream over which to calculate the CRC32</param>
            <param name="output">The stream into which to deflate the input</param>
            <returns>the CRC32 calculation</returns>
        </member>
        <member name="M:Ionic.Utils.Zip.CRC32.ComputeCrc32(System.Int32,System.Byte)">
            <summary>
            Get the CRC32 for the given (word,byte) combo. 
            This is a computation defined by PKzip.
            </summary>
            <param name="W">The word to start with.</param>
            <param name="B">The byte to combine it with.</param>
            <returns>The CRC-ized result.</returns>
        </member>
        <member name="M:Ionic.Utils.Zip.CRC32.SlurpBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the value for the running CRC32 using the given block of bytes.
            This is useful when using the CRC32() class in a Stream.
            </summary>
            <param name="block">block of bytes to slurp</param>
            <param name="offset">starting point in the block</param>
            <param name="count">how many bytes within the block to slurp</param>
        </member>
        <member name="M:Ionic.Utils.Zip.CRC32.#ctor">
            <summary>
            Construct an instance of the CRC32 class, pre-initialising the table
            for speed of lookup.
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.CRC32.TotalBytesRead">
            <summary>
            indicates the total number of bytes read on the CRC stream.
            This is used when writing the ZipDirEntry when compressing files.
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.CRC32.Crc32Result">
            <summary>
            Indicates the current CRC for all blocks slurped in.
            </summary>
        </member>
        <member name="T:Ionic.Utils.Zip.CrcCalculatorStream">
             <summary>
             A read-only, forward-only Stream that calculates a CRC, a checksum, on all bytes read, 
             or on all bytes written.
             </summary>
            
             <remarks>
             This class can be used to verify the CRC of a ZipEntry when reading from a stream, 
             or to calculate a CRC when writing to a stream.  The stream should be used to either 
             read, or write, but not both.  If you intermix reads and writes, the results are
             not defined.
             </remarks>
        </member>
        <member name="M:Ionic.Utils.Zip.CrcCalculatorStream.#ctor(System.IO.Stream)">
            <summary>
            The constructor.
            </summary>
            <param name="stream">The underlying stream</param>
        </member>
        <member name="M:Ionic.Utils.Zip.CrcCalculatorStream.#ctor(System.IO.Stream,System.Int32)">
            <summary>
            The constructor.
            </summary>
            <param name="stream">The underlying stream</param>
            <param name="length">The length of the stream to slurp</param>
        </member>
        <member name="M:Ionic.Utils.Zip.CrcCalculatorStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read from the stream
            </summary>
            <param name="buffer">the buffer to read</param>
            <param name="offset">the offset at which to start</param>
            <param name="count">the number of bytes to read</param>
            <returns>the number of bytes actually read</returns>
        </member>
        <member name="M:Ionic.Utils.Zip.CrcCalculatorStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Write to the stream. 
            </summary>
            <param name="buffer">the buffer from which to write</param>
            <param name="offset">the offset at which to start writing</param>
            <param name="count">the number of bytes to write</param>
        </member>
        <member name="M:Ionic.Utils.Zip.CrcCalculatorStream.Flush">
            <summary>
            Not implemented.
            </summary>
        </member>
        <member name="M:Ionic.Utils.Zip.CrcCalculatorStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Not implemented.
            </summary>
            <param name="offset">N/A</param>
            <param name="origin">N/A</param>
            <returns>N/A</returns>
        </member>
        <member name="M:Ionic.Utils.Zip.CrcCalculatorStream.SetLength(System.Int64)">
            <summary>
            Not implemented.
            </summary>
            <param name="value">N/A</param>
        </member>
        <member name="P:Ionic.Utils.Zip.CrcCalculatorStream.TotalBytesSlurped">
             <summary>
             Gets the total number of bytes run through the CRC32 calculator.
             </summary>
            
             <remarks>
             This is either the total number of bytes read, or the total number
             of bytes written, depending on the direction of this stream.
             </remarks>
        </member>
        <member name="P:Ionic.Utils.Zip.CrcCalculatorStream.Crc32">
            <summary>
            Provides the current CRC for all blocks slurped in.
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.CrcCalculatorStream.CanRead">
            <summary>
            Indicates whether the stream supports reading. Always returns true.
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.CrcCalculatorStream.CanSeek">
            <summary>
            Indicates whether the stream supports seeking. Always returns false.
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.CrcCalculatorStream.CanWrite">
            <summary>
            Indicates whether the stream supports writing. Always returns true.
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.CrcCalculatorStream.Length">
            <summary>
            Not implemented.
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.CrcCalculatorStream.Position">
            <summary>
            Not implemented.
            </summary>
        </member>
        <member name="T:Ionic.Utils.Zip.ZipCrypto">
            <summary> 
            This class implements the "traditional" or "classic" PKZip encryption,
            which today is considered to be weak. On the other hand it is
            ubiquitous. This class is intended for use only by the DotNetZip library.
            </summary>
            <remarks>
            Most uses of the DotNetZip library will not involve direct calls into the
            ZipCrypto class.  Instead, the ZipCrypto class is instantiated and used by
            the ZipEntry() class when encryption or decryption on an entry is employed.
            If for some reason you really wanted to use a weak encryption algorithm
            in some other application, you might use this library.  But you would be much
            better off using one of the built-in strong encryption libraries in the 
            .NET Framework, like the AES algorithm or SHA. 
            </remarks>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipCrypto.#ctor">
            <summary>
            The default constructor.  You're probably never gonna call this.  Seriously.
            Stop reading this documentation.  It's not useful to you.  Go do something else.
            Check the football scores. Go get an ice cream with a friend.  Seriously.
            </summary>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipCrypto.DecryptMessage(System.Byte[],System.Int32)">
            <summary> 
            Call this method on a cipher text to render the plaintext. You must
            first initialize the cipher with a call to InitCipher.
            </summary>		
            <example>
            <code>
            var cipher = new ZipCrypto();
            cipher.InitCipher(Password);
            // Decrypt the header.  This has a side effect of "further initializing the
            // encryption keys" in the traditional zip encryption. 
            byte[] DecryptedMessage = cipher.DecryptMessage(EncryptedMessage);
            </code>
            </example>
            <param name="cipherText">The encrypted buffer.</param>
            <param name="length">
            The number of bytes to encrypt.  
            Should be less than or equal to CipherText.Length.
            </param>
            <returns>The plaintext.</returns>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipCrypto.EncryptMessage(System.Byte[],System.Int32)">
            <summary>
            This is the converse of DecryptMessage.  It encrypts the plaintext
            and produces a ciphertext. 
            </summary>
            <param name="plaintext">The plain text buffer.</param>
            <param name="length">
            The number of bytes to encrypt.  
            Should be less than or equal to PlainText.Length.
            </param>
            <returns>The ciphertext.</returns>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipCrypto.InitCipher(System.String)">
             <summary>
             This initializes the cipher with the given password. 
             See AppNote.txt for details. 
             </summary>
             <param name="passphrase">The passphrase for encrypting or decrypting with this cipher.
             </param>
             <remarks>
             <code>
             Step 1 - Initializing the encryption keys
             -----------------------------------------
             Start with these keys:        
             Key(0) := 305419896 (0x12345678)
             Key(1) := 591751049 (0x23456789)
             Key(2) := 878082192 (0x34567890)
             
             Then, initialize the keys with a password:
             
             loop for i from 0 to length(password)-1
                 update_keys(password(i))
             end loop
             
             Where update_keys() is defined as:
             
             update_keys(char):
               Key(0) := crc32(key(0),char)
               Key(1) := Key(1) + (Key(0) bitwiseAND 000000ffH)
               Key(1) := Key(1) * 134775813 + 1
               Key(2) := crc32(key(2),key(1) rightshift 24)
             end update_keys
             
             Where crc32(old_crc,char) is a routine that given a CRC value and a
             character, returns an updated CRC value after applying the CRC-32
             algorithm described elsewhere in this document.
            
             </code>
             <para>
             After the keys are initialized, then you can use the cipher to encrypt
             the plaintext. 
             </para>
             <para>
             Essentially we encrypt the password with the keys, then discard the 
             ciphertext for the password. This initializes the keys for later use.
             </para>
             </remarks>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipCrypto.MagicByte">
            <summary> 
            From AppNote.txt:
            unsigned char decrypt_byte()
                local unsigned short temp
                temp :=- Key(2) | 2
                decrypt_byte := (temp * (temp ^ 1)) bitshift-right 8
            end decrypt_byte
            </summary>		
        </member>
        <member name="T:Ionic.Utils.Zip.ZipCipherStream">
            <summary>
            A Stream for reading and concurrently decrypting data from a zip file, 
            or for writing and concurrently encrypting data to a zip file.
            </summary>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipCipherStream.#ctor(System.IO.Stream,Ionic.Utils.Zip.ZipCrypto,Ionic.Utils.Zip.CryptoMode)">
            <summary>
            The  constructor.
            </summary>
            <param name="s">The underlying stream</param>
            <param name="mode">To either encrypt or decrypt.</param>
            <param name="cipher">The pre-initialized ZipCrypto object.</param>
        </member>
        <member name="T:Ionic.Utils.Zip.ReReadApprovalCallback">
            <summary>
            Delegate for the callback by which the application gives approval for multiple
            reads of the file stream. This callback is called only when the initial 
            compression operation inflates the size of the file data. 
            </summary>
        </member>
        <member name="T:Ionic.Utils.Zip.WantCompressionCallback">
            <summary>
            Delegate for the callback by which the application tells the libraary whether
            to use compression on the file or not.  Using this callback, the application can 
            specify that previously-compressed files (.mp3, .png, .docx, etc) should 
            not be compressed, for example, or can turn on or off compression based on any 
            other factor.
            </summary>
        </member>
        <member name="T:Ionic.Utils.Zip.ZipProgressEventArgs">
            <summary>
            Provides information about the progress of a save or extract operation.
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipProgressEventArgs.EntriesTotal">
            <summary>
            The total number of entries to be saved or extracted.
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipProgressEventArgs.NameOfLatestEntry">
            <summary>
            The name of the last entry saved or extracted.
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipProgressEventArgs.Cancel">
            <summary>
            In an event handler, set this to cancel the save or extract 
            operation that is in progress.
            </summary>
        </member>
        <member name="T:Ionic.Utils.Zip.SaveProgressEventArgs">
            <summary>
            Provides information about the progress of a save operation.
            </summary>
        </member>
        <member name="M:Ionic.Utils.Zip.SaveProgressEventArgs.#ctor(System.Int32,System.Int32,System.String)">
            <summary>
            Constructor for the SaveProgressEventArgs.
            </summary>
            <param name="entriesTotal">The total number of entries in the zip archive.</param>
            <param name="entriesSaved">Number of entries that have been saved.</param>
            <param name="lastEntry">The last entry saved.</param>
        </member>
        <member name="P:Ionic.Utils.Zip.SaveProgressEventArgs.EntriesSaved">
            <summary>
            Number of entries saved so far.
            </summary>
        </member>
        <member name="T:Ionic.Utils.Zip.ExtractProgressEventArgs">
            <summary>
            Provides information about the progress of the extract operation.
            </summary>
        </member>
        <member name="M:Ionic.Utils.Zip.ExtractProgressEventArgs.#ctor(System.Int32,System.Int32,System.String,System.String,System.Boolean)">
            <summary>
            Constructor for the ExtractProgressEventArgs.
            </summary>
            <param name="entriesTotal">The total number of entries in the zip archive.</param>
            <param name="entriesExtracted">Number of entries that have been extracted.</param>
            <param name="lastEntry">The last entry extracted.</param>
            <param name="extractLocation">The location to which entries are extracted.</param>
            <param name="wantOverwrite">indicates whether the extract operation will overwrite existing files.</param>
        </member>
        <member name="P:Ionic.Utils.Zip.ExtractProgressEventArgs.EntriesExtracted">
            <summary>
            Number of entries extracted so far.
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.ExtractProgressEventArgs.Overwrite">
            <summary>
            True if the extract operation overwrites existing files.
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.ExtractProgressEventArgs.ExtractLocation">
            <summary>
            Returns the extraction target location, a filesystem path. 
            </summary>
        </member>
        <member name="T:Ionic.Utils.Zip.SaveEventArgs">
            <summary>
            Used to provide event information about the Save .
            </summary>
        </member>
        <member name="M:Ionic.Utils.Zip.SaveEventArgs.#ctor(System.String)">
            <summary>
            Constructor for a SaveEventArgs.
            </summary>
            <param name="archiveName">The name of the archive being saved.</param>
        </member>
        <member name="P:Ionic.Utils.Zip.SaveEventArgs.ArchiveName">
            <summary>
            Returns the archive name.
            </summary>
        </member>
        <member name="T:Ionic.Utils.Zip.ExtractEventArgs">
            <summary>
            Used to provide event information about the Extract operation.
            </summary>
        </member>
        <member name="M:Ionic.Utils.Zip.ExtractEventArgs.#ctor(System.String,System.String,System.Boolean)">
            <summary>
            Constructor for a ExtractEventArgs.
            </summary>
            <param name="archiveName">The name of the archive being extracted.</param>
            <param name="extractLocation">The location to which  the archive is being extracted.</param>
            <param name="wantOverwrite">whether the extract operation overwrites existing files.</param>
        </member>
        <member name="P:Ionic.Utils.Zip.ExtractEventArgs.ArchiveName">
            <summary>
            Returns the archive name.
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.ExtractEventArgs.ExtractLocation">
            <summary>
            Returns the extraction target location, or "(stream)" if the target is a stream.
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.ExtractEventArgs.Overwrite">
            <summary>
            A boolean indicating whether the extract operation overwrites existing files.
            </summary>
        </member>
        <member name="T:Ionic.Utils.Zip.EncryptionAlgorithm">
            <summary>
            An enum that provides the various encryption algorithms supported by this library.
            </summary>
        </member>
        <member name="F:Ionic.Utils.Zip.EncryptionAlgorithm.None">
            <summary>
            No encryption at all.
            </summary>
        </member>
        <member name="F:Ionic.Utils.Zip.EncryptionAlgorithm.PkzipWeak">
            <summary>
            Traditional or Classic pkzip encryption.
            </summary>
        </member>
        <member name="T:Ionic.Utils.Zip.EntrySource">
            <summary>
            An enum that specifies the source of the ZipEntry. 
            </summary>
        </member>
        <member name="F:Ionic.Utils.Zip.EntrySource.None">
            <summary>
            Default value.  Invalid on a bonafide ZipEntry.
            </summary>
        </member>
        <member name="F:Ionic.Utils.Zip.EntrySource.Filesystem">
            <summary>
            Entry was instantiated by Adding an entry from the filesystem.
            </summary>
        </member>
        <member name="F:Ionic.Utils.Zip.EntrySource.Zipfile">
            <summary>
            Entry was instantiated by reading a zipfile.
            </summary>
        </member>
        <member name="F:Ionic.Utils.Zip.EntrySource.Stream">
            <summary>
            Entry was instantiated via a stream or string.
            </summary>
        </member>
        <member name="T:Ionic.Utils.Zip.ZipEntry">
            <summary>
            Represents a single entry in a ZipFile. Typically, applications
            get a ZipEntry by enumerating the entries within a ZipFile,
            or by adding an entry to a ZipFile.  
            </summary>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipEntry.Read(System.IO.Stream,System.Text.Encoding)">
            <summary>
            Reads one ZipEntry from the given stream.  If the entry is encrypted, we don't
            actuall decrypt at this point. 
            </summary>
            <param name="s">the stream to read from.</param>
            <param name="defaultEncoding">
            The text encoding to use when reading the ZipEntry, if it is not marked as UTF-8.
            </param>
            <returns>the ZipEntry read from the stream.</returns>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipEntry.Extract">
             <summary>
             Extract the entry to the filesystem, starting at the current working directory. 
             </summary>
             
             <overloads>
             This method has a bunch of overloads! One of them is sure to be
             the right one for you... If you don't like these, check out the 
             <c>ExtractWithPassword()</c> methods.
             </overloads>
                     
             <seealso cref="P:Ionic.Utils.Zip.ZipEntry.OverwriteOnExtract"/>
             <seealso cref="M:Ionic.Utils.Zip.ZipEntry.Extract(System.Boolean)"/>
            
             <remarks>
             <para>
             Existing entries in the filesystem will not be overwritten. If you would like to 
             force the overwrite of existing files, see the <c>OverwriteOnExtract</c> property, 
             or try one of the overloads of the Extract method that accept a boolean flag
             to indicate explicitly whether you want overwrite.
             </para>
             <para>
             See the remarks on the LastModified property, for some details 
             about how the last modified time of the created file is set.
             </para>
             </remarks>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipEntry.Extract(System.Boolean)">
            <summary>
            Extract the entry to a file in the filesystem, potentially overwriting
            any existing file.
            </summary>
            <remarks>
            <para>
            See the remarks on the LastModified property, for some details 
            about how the last modified time of the created file is set.
            </para>
            </remarks>
            <param name="overwrite">true if the caller wants to overwrite an existing file by the same name in the filesystem.</param>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipEntry.Extract(System.IO.Stream)">
            <summary>
            Extracts the entry to the specified stream. 
            For example, the caller could specify Console.Out, or a MemoryStream.
            </summary>
            
            <param name="stream">the stream to which the entry should be extracted.  </param>
            
            <remarks>
            <para>
            See the remarks on the LastModified property, for some details 
            about how the last modified time of the created file is set.
            </para>
            </remarks>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipEntry.Extract(System.String)">
            <summary>
            Extract the entry to the filesystem, starting at the specified base directory. 
            </summary>
            
            <param name="baseDirectory">the pathname of the base directory</param>
            
            <seealso cref="P:Ionic.Utils.Zip.ZipEntry.OverwriteOnExtract"/>
            <seealso cref="M:Ionic.Utils.Zip.ZipEntry.Extract(System.String,System.Boolean)"/>
            <seealso cref="M:Ionic.Utils.Zip.ZipFile.Extract(System.String)"/>
            
            <example>
            This example extracts only the entries in a zip file that are .txt files, into a directory called "textfiles".
            <code lang="C#">
            using (ZipFile zip = ZipFile.Read("PackedDocuments.zip"))
            {
              foreach (string s1 in zip.EntryFilenames)
              {
                if (s1.EndsWith(".txt")) 
                {
                  ZipEntry entry= zip[s1];
                  entry.Extract("textfiles");
                }
              }
            }
            </code>
            <code lang="VB">
              Using zip As ZipFile = ZipFile.Read("PackedDocuments.zip")
                  Dim s1 As String
                  For Each s1 In zip.EntryFilenames
                      If s1.EndsWith(".txt") Then
                          Dim entry as ZipEntry
                          entry = zip(s1)
                          entry.Extract("textfiles")
                      End If
                  Next
              End Using
            </code>
            </example>
            
            <remarks>
            <para>
            Existing entries in the filesystem will not be overwritten. If you would like to 
            force the overwrite of existing files, see the <c>OverwriteOnExtract</c> property, 
            or try one of the overloads of the Extract method that accept a boolean flag
            to indicate explicitly whether you want overwrite.
            </para>
            <para>
            See the remarks on the LastModified property, for some details 
            about how the last modified time of the created file is set.
            </para>
            </remarks>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipEntry.Extract(System.String,System.Boolean)">
            <summary>
            Extract the entry to the filesystem, starting at the specified base directory, 
            and potentially overwriting existing files in the filesystem. 
            </summary>
            
            <remarks>
            <para>
            See the remarks on the LastModified property, for some details 
            about how the last modified time of the created file is set.
            </para>
            </remarks>
            
            <param name="baseDirectory">the pathname of the base directory</param>
            <param name="overwrite">If true, overwrite any existing files if necessary upon extraction.</param>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipEntry.ExtractWithPassword(System.String)">
             <summary>
             Extract the entry to the filesystem, using the current working directory,
             and using the specified password. 
             </summary>
            
             <overloads>
             This method has a bunch of overloads! One of them is sure to be
             the right one for you...
             </overloads>
                     
             <seealso cref="P:Ionic.Utils.Zip.ZipEntry.OverwriteOnExtract"/>
             <seealso cref="M:Ionic.Utils.Zip.ZipEntry.ExtractWithPassword(System.Boolean,System.String)"/>
            
             <remarks>
             <para>
             Existing entries in the filesystem will not be overwritten. If you would like to 
             force the overwrite of existing files, see the <c>OverwriteOnExtract</c> property, 
             or try one of the overloads of the ExtractWithPassword method that accept a boolean flag
             to indicate explicitly whether you want overwrite.
             </para>
             <para>
             See the remarks on the LastModified property, for some details 
             about how the last modified time of the created file is set.
             </para>
             </remarks>
            
             <param name="password">The Password to use for decrypting the entry.</param>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipEntry.ExtractWithPassword(System.String,System.String)">
             <summary>
             Extract the entry to the filesystem, starting at the specified base directory,
             and using the specified password. 
             </summary>
             
             <seealso cref="P:Ionic.Utils.Zip.ZipEntry.OverwriteOnExtract"/>
             <seealso cref="M:Ionic.Utils.Zip.ZipEntry.ExtractWithPassword(System.String,System.Boolean,System.String)"/>
            
             <remarks>
             <para>
             Existing entries in the filesystem will not be overwritten. If you would like to 
             force the overwrite of existing files, see the <c>OverwriteOnExtract</c> property, 
             or try one of the overloads of the ExtractWithPassword method that accept a boolean flag
             to indicate explicitly whether you want overwrite.
             </para>
             <para>
             See the remarks on the LastModified property, for some details 
             about how the last modified time of the created file is set.
             </para>
             </remarks>
             
             <param name="baseDirectory">The pathname of the base directory.</param>
             <param name="password">The Password to use for decrypting the entry.</param>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipEntry.ExtractWithPassword(System.Boolean,System.String)">
            <summary>
            Extract the entry to a file in the filesystem, potentially overwriting
            any existing file.
            </summary>
            
            <remarks>
            <para>
            See the remarks on the LastModified property, for some details 
            about how the last modified time of the created file is set.
            </para>
            </remarks>
            
            <param name="overwrite">true if the caller wants to overwrite an existing 
            file by the same name in the filesystem.</param>
            <param name="password">The Password to use for decrypting the entry.</param>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipEntry.ExtractWithPassword(System.String,System.Boolean,System.String)">
             <summary>
             Extract the entry to the filesystem, starting at the specified base directory, 
             and potentially overwriting existing files in the filesystem. 
             </summary>
             
             <remarks>
             See the remarks on the LastModified property, for some details 
             about how the last modified time of the created file is set.
             </remarks>
            
             <param name="baseDirectory">the pathname of the base directory</param>
             <param name="overwrite">If true, overwrite any existing files if necessary upon extraction.</param>
             <param name="password">The Password to use for decrypting the entry.</param>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipEntry.ExtractWithPassword(System.IO.Stream,System.String)">
            <summary>
            Extracts the entry to the specified stream, using the specified Password.
            For example, the caller could extract to Console.Out, or to a MemoryStream.
            </summary>
            
            <remarks>
            See the remarks on the LastModified property, for some details 
            about how the last modified time of the created file is set.
            </remarks>
            
            <param name="stream">the stream to which the entry should be extracted.  </param>
            <param name="password">The password to use for decrypting the entry.</param>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipEntry.OpenReader">
            <summary>
            Opens the backing stream for the zip entry in the archive, for reading. 
            </summary>
            <remarks>
            <para>
            The ZipEntry has methods that extract the entry to an already-opened stream.
            This is an alternative method for those applications that wish to manipulate the stream directly.
            </para>
            <para>
            The CrcCalculatorStream that is returned is just a regular read-only stream - you can use it as you would
            any stream.  The one additional feature it adds is that it calculates a CRC32 on the bytes of the stream 
            as it is read.  This CRC should be used by the application to validate the content of the ZipEntry, when 
            the read is complete.  Check the example for how to do this. 
            </para>
            <para>
            If the entry is protected with a password, then you need to set the password on the entry prior to calling OpenReader().
            </para>
            </remarks>
            <example>
            In this example, we open a zipfile, then read in a named entry via a stream, scanning
            the bytes in the entry as we go.  Finally, the CRC and the size of the entry are verified.
            <code>
            using (ZipFile zip = new ZipFile(ZipFileToRead))
            {
              ZipEntry e1= zip["Download.mp3"];
              using (CrcCalculatorStream s = e1.OpenReader())
              {
                byte[] buffer = new byte[4096];
                int n, totalBytesRead= 0;
                do {
                  n = s.Read(buffer,0, buffer.Length);
                  totalBytesRead+=n; 
                } while (n&gt;0);
                 if (s.Crc32 != e1.Crc32)
                  throw new Exception(string.Format("The Zip Entry failed the CRC Check. (0x{0:X8}!=0x{1:X8})", s.Crc32, e1.Crc32));
                 if (totalBytesRead != e1.UncompressedSize)
                  throw new Exception(string.Format("We read an unexpected number of bytes. ({0}!={1})", totalBytesRead, e1.UncompressedSize));
              }
            }
            </code>
            <code lang="VB">
              Using zip As New ZipFile(ZipFileToRead)
                  Dim e1 As ZipEntry = zip.Item("Download.mp3")
                  Using s As CrcCalculatorStream = e1.OpenReader
                      Dim n As Integer
                      Dim buffer As Byte() = New Byte(4096) {}
                      Dim totalBytesRead As Integer = 0
                      Do
                          n = s.Read(buffer, 0, buffer.Length)
                          totalBytesRead = (totalBytesRead + n)
                      Loop While (n &gt; 0)
                      If (s.Crc32 &lt;&gt; e1.Crc32) Then
                          Throw New Exception(String.Format("The Zip Entry failed the CRC Check. (0x{0:X8}!=0x{1:X8})", s.Crc32, e1.Crc32))
                      End If
                      If (totalBytesRead &lt;&gt; e1.UncompressedSize) Then
                          Throw New Exception(String.Format("We read an unexpected number of bytes. ({0}!={1})", totalBytesRead, e1.UncompressedSize))
                      End If
                  End Using
              End Using
            </code>
            </example>
            <seealso cref="M:Ionic.Utils.Zip.ZipEntry.Extract(System.IO.Stream)"/>
            <returns>The Stream for reading.</returns>
        </member>
        <member name="M:Ionic.Utils.Zip.ZipEntry.OpenReader(System.String)">
            <summary>
            Opens the backing stream for an encrypted zip entry in the archive, for reading. 
            </summary>
            <remarks>
            <para>
            See the documentation on the OpenReader() method for full details.  This overload allows the 
            application to specify a password for the ZipEntry to be read. 
            </para>
            </remarks>
            <param name="password">The password to use for decrypting the entry.</param>
            <returns>The Stream for reading.</returns>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipEntry.LastModified">
             <summary>
             The time and date at which the file indicated by the ZipEntry was last modified. 
             </summary>
             
             <remarks>
             <para>
             The DotNetZip library sets the LastModified value for an entry, equal to the 
             Last Modified time of the file in the filesystem.  If an entry is added from a stream, 
             in which case no Last Modified attribute is available, the library uses 
             <c>System.DateTime.Now</c> for this value, for the given entry. 
             </para>
            
             <para>
             It is also possible to set the LastModified value on an entry, to an arbitrary
             value.  Be aware that because of the way the PKZip specification describes how
             times are stored in the zip file, the full precision of the
             <c>System.DateTime</c> datatype is not stored in LastModified when saving zip
             files.  For more information on how times are formatted, see the PKZip
             specification.
             </para>
            
             <para>
             The last modified time of the file created upon a call to <c>ZipEntry.Extract()</c> 
             may be adjusted during extraction to compensate
             for differences in how the .NET Base Class Library deals
             with daylight saving time (DST) versus how the Windows
             filesystem deals with daylight saving time. 
             See http://blogs.msdn.com/oldnewthing/archive/2003/10/24/55413.aspx for more context.
             </para>
             <para>
             In a nutshell: Daylight savings time rules change regularly.  In
             2007, for example, the inception week of DST changed.  In 1977,
             DST was in place all year round. In 1945, likewise.  And so on.
             Win32 does not attempt to guess which time zone rules were in
             effect at the time in question.  It will render a time as
             "standard time" and allow the app to change to DST as necessary.
              .NET makes a different choice.
             </para>
             <para>
             Compare the output of FileInfo.LastWriteTime.ToString("f") with
             what you see in the property sheet for a file that was last
             written to on the other side of the DST transition. For example,
             suppose the file was last modified on October 17, 2003, during DST but
             DST is not currently in effect. Explorer's file properties
             reports Thursday, October 17, 2003, 8:45:38 AM, but .NETs
             FileInfo reports Thursday, October 17, 2003, 9:45 AM.
             </para>
             <para>
             Win32 says, "Thursday, October 17, 2002 8:45:38 AM PST". Note:
             Pacific STANDARD Time. Even though October 17 of that year
             occurred during Pacific Daylight Time, Win32 displays the time as
             standard time because that's what time it is NOW.
             </para>
             <para>
             .NET BCL assumes that the current DST rules were in place at the
             time in question.  So, .NET says, "Well, if the rules in effect
             now were also in effect on October 17, 2003, then that would be
             daylight time" so it displays "Thursday, October 17, 2003, 9:45
             AM PDT" - daylight time.
             </para>
             <para>
             So .NET gives a value which is more intuitively correct, but is
             also potentially incorrect, and which is not invertible. Win32
             gives a value which is intuitively incorrect, but is strictly
             correct.
             </para>
             <para>
             Because of this funkiness, this library adds one hour to the LastModified time
             on the extracted file, if necessary.  That is to say, if the time in question
             had occurred in what the .NET Base Class Library assumed to be DST (an
             assumption that may be wrong given the constantly changing DST rules).
             </para>
             </remarks>
            
        </member>
        <member name="P:Ionic.Utils.Zip.ZipEntry.TrimVolumeFromFullyQualifiedPaths">
            <summary>
            When this is set, this class trims the volume (eg C:\) from any
            fully-qualified pathname on the ZipEntry, before writing the ZipEntry into
            the ZipFile. This flag affects only zip creation. By default, this flag is TRUE,
            which means volume names will not be included in the filenames on entries in
            the archive.  Your best bet is to just leave this alone.
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipEntry.ForceNoCompression">
            <summary>
            When this is set, the entry is not compressed when written to 
            the archive.  For example, the application might want to set flag to True
            this when zipping up JPG or MP3 files, which are already compressed.
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipEntry.LocalFileName">
            <summary>
            The name of the filesystem file, referred to by the ZipEntry. 
            </summary>
            
            <remarks>
            <para>
            This may be different than the path used in the archive itself. What I mean is, 
            if you call Zip.AddFile("fooo.txt"", AlternativeDirectory), then the 
            path used in the zip entry will be different than this path.  This path is 
            used to locate the thing-to-be-zipped on disk. 
            </para>
            <para>
            If the entry is being added from a stream, then this is null (Nothing in VB).
            </para>
            
            </remarks>
            <seealso cref="P:Ionic.Utils.Zip.ZipEntry.FileName"/>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipEntry.FileName">
             <summary>
             The name of the file contained in the ZipEntry. 
             </summary>
             
             <remarks>
             <para>
             When writing a zip, this path has backslashes replaced with 
             forward slashes, according to the zip spec, for compatibility
             with Unix(tm) and ... get this.... Amiga!
             </para>
            
             <para>
             This is the name of the entry in the ZipFile itself.  This name may be different
             than the name of the filesystem file used to create the entry. In fact, there
             may be no filesystem file at all, if the entry is created from a stream or a string.
             </para>
             </remarks>
             <seealso cref="P:Ionic.Utils.Zip.ZipEntry.LocalFileName"/>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipEntry.VersionNeeded">
            <summary>
            The version of the zip engine needed to read the ZipEntry.  This is usually 0x14. 
            (Decimal 20).
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipEntry.Comment">
            <summary>
            The comment attached to the ZipEntry. 
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipEntry.BitField">
             <summary>
             The bitfield as defined in the zip spec. In the current implementation, the
             only thing this library potentially writes to the general purpose
             Bitfield is an encryption indicators.
             </summary>
             <code>
             bit  0 - set if encryption is used.
             b. 1-2 - set to determine whether normal, max, fast deflation.  
                      This library always leaves these bits unset when writing (indicating 
                      "normal" deflation").
            
             bit  3 - indicates crc32, compressed and uncompressed sizes are zero in
                      local header.  We always leave this as zero on writing, but can read
                      a zip with it nonzero. 
            
             bit  4 - reserved for "enhanced deflating". This library doesn't do enhanced deflating.
             bit  5 - set to indicate the zip is compressed patched data.  This library doesn't do that.
             bit  6 - set if strong encryption is used (must also set bit 1 if bit 6 is set)
             bit  7 - unused
             bit  8 - unused
             bit  9 - unused
             bit 10 - unused
             Bit 11 - Language encoding flag (EFS).  If this bit is set,
                      the filename and comment fields for this file
                      must be encoded using UTF-8. This library currently does not support UTF-8.
             Bit 12 - Reserved by PKWARE for enhanced compression.
             Bit 13 - Used when encrypting the Central Directory to indicate 
                      selected data values in the Local Header are masked to
                      hide their actual values.  See the section describing 
                      the Strong Encryption Specification for details.
             Bit 14 - Reserved by PKWARE.
             Bit 15 - Reserved by PKWARE.
             </code>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipEntry.CompressionMethod">
            <summary>
            The compression method employed for this ZipEntry. 0x08 = Deflate.  0x00 =
            Store (no compression).  Really, this should be an enum.  But the zip spec
            makes it a byte. So here it is. 
            </summary>
            
            <remarks>
            <para>When reading an entry from an existing zipfile, the value you retrieve here
            indicates the compression method used on the entry by the original creator of the zip.  
            When writing a zipfile, you can specify either 0x08 (Deflate) or 0x00 (None).  If you 
            try setting something else, it will throw an exception.  
            </para>
            <para>
            You may wish to set CompressionMethod to 0 (None) when zipping previously compressed
            data like jpg, png, or mp3 files.  This can save time and cpu cycles.
            </para>
            </remarks>
            
            <example>
            In this example, the first entry added to the zip archive uses 
            the default behavior - compression is used where it makes sense.  
            The second entry, the MP3 file, is added to the archive without being compressed.
            <code>
            using (ZipFile zip = new ZipFile(ZipFileToCreate))
            {
              ZipEntry e1= zip.AddFile(@"c:\temp\Readme.txt");
              ZipEntry e2= zip.AddFile(@"c:\temp\StopThisTrain.mp3");
              e2.CompressionMethod = 0;
              zip.Save();
            }
            </code>
            
            <code lang="VB">
            Using zip as new ZipFile(ZipFileToCreate)
              zip.AddFile("c:\temp\Readme.txt")
              Dim e2 as ZipEntry = zip.AddFile("c:\temp\StopThisTrain.mp3")
              e2.CompressionMethod = 0
              zip.Save
            End Using
            </code>
            </example>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipEntry.CompressedSize">
            <summary>
            The compressed size of the file, in bytes, within the zip archive. 
            </summary>
            <remarks>
            The compressed size is computed during compression. This means that it is only
            valid to read this AFTER reading in an existing zip file, or AFTER saving a
            zipfile you are creating.
            </remarks>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipEntry.UncompressedSize">
            <summary>
            The size of the file, in bytes, before compression, or after extraction. 
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipEntry.CompressionRatio">
            <summary>
            The ratio of compressed size to uncompressed size. This is a double in the
            range of 0 to 100.  You could print it with a format string of "{3,5:F0}%"
            to see it as a percentage. If the size of the original uncompressed file is 0, 
            the return value will be zero. 
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipEntry.Crc32">
            <summary>
            The CRC (Cyclic Redundancy Check) on the contents of the ZipEntry.
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipEntry.IsDirectory">
            <summary>
            True if the entry is a directory (not a file). 
            This is a readonly property on the entry.
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipEntry.UsesEncryption">
            <summary>
            A derived property that is True if the entry uses encryption.  
            This is a readonly property on the entry.
            Upon reading an entry, this bool is determined by
            the data read.  When writing an entry, this bool is
            determined by whether the Encryption property is set to something other than
            EncryptionAlgorithm.None. 
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipEntry.Encryption">
            <summary>
            Set this to specify which encryption algorithm to use for the entry.
            In order for this to succeed, you must also set a Password on the entry.
            The set of algoritms is determined by the PKZIP specification from PKWare.
            The "traditional" encryption used by PKZIP is considered weak.  PKZip also
            supports strong encryption mechanisms including AES of various keysizes and
            Blowfish, among others.  This library does not implement the full PKZip
            spec. 
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipEntry.Password">
            <summary>
            Set this to request that the entry be encrypted when writing the zip
            archive.  This is a write-only property on the entry. The password 
            is used to encrypt the entry during the Save() operation, or decrypt during
            the Extract() or OpenReader() operation. 
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipEntry.OverwriteOnExtract">
            <summary>
            Specifies that the extraction should overwrite any existing files.
            This applies only when calling an Extract method. By default this 
            property is false. 
            </summary>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipEntry.WillReadTwiceOnInflation">
             <summary>
             A callback that allows the application to specify whether multiple reads of the
             stream should be performed, in the case that a compression operation actually
             inflates the size of the file data.  
             </summary>
            
             <remarks>
             <para>
             In some cases, applying the Deflate compression algorithm in DeflateStream can
             result an increase in the size of the data.  This "inflation" can happen with
             previously compressed files, such as a zip, jpg, png, mp3, and so on.  In a few
             tests, inflation on zip files can be as large as 60%!  Inflation can also happen
             with very small files.  In these cases, by default, the DotNetZip library
             discards the compressed bytes, and stores the uncompressed file data into the
             zip archive.  This is an optimization where smaller size is preferred over
             longer run times.
             </para>
            
             <para>
             The application can specify that compression is not even tried, by setting the
             ForceNoCompression flag.  In this case, the compress-and-check-sizes process as
             decribed above, is not done.
             </para>
            
             <para>
             In some cases, neither choice is optimal.  The application wants compression,
             but in some cases also wants to avoid reading the stream more than once.  This
             may happen when the stream is very large, or when the read is very expensive, or
             when the difference between the compressed and uncompressed sizes is not
             significant.
             </para>
            
             <para>
             To satisfy these applications, this delegate allows the DotNetZip library to ask
             the application to for approval for re-reading the stream.  As with other
             properties (like Password and ForceNoCompression), setting the corresponding
             delegate on the ZipFile class itself will set it on all ZipEntry items that are
             subsequently added to the ZipFile instance.
             </para>
            
             </remarks>
             <seealso cref="P:Ionic.Utils.Zip.ZipFile.WillReadTwiceOnInflation"/>
             <seealso cref="T:Ionic.Utils.Zip.ReReadApprovalCallback"/>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipEntry.WantCompression">
             <summary>
             A callback that allows the application to specify whether compression should
             be used for a given entry that is about to be added to the zip archive.
             </summary>
            
             <remarks>
             <para>
             In some cases, applying the Deflate compression algorithm to an entry can
             result an increase in the size of the data.  This "inflation" can happen with
             previously compressed files, such as a zip, jpg, png, mp3, and so on.  In a few
             tests, inflation on zip files can be as large as 60%!  Inflation can also happen
             with very small files.  
             </para>
            
             <para>
             To handle these cases, the DotNetZip library takes this approach: first it
             applies a heuristic, to determine whether it should try to compress a file or
             not.  The library checks the extension of the entry, and if it is one of a
             known list of uncompressible file types (mp3, zip, docx, and others), the
             library will not attempt to compress the entry.  The library does not actually
             check the content of the entry.  If you name a text file "Text.zip", and then
             attempt to add it to a zip archive, this library will, by default, not attempt
             to compress the entry.
             </para>
            
             <para>
             For filetypes not covered by that heuristic, the library attempts to compress
             the entry, and then checks the size of the result.  If applying the Deflate
             algorithm increases the size of the data, then the library discards the
             compressed bytes, and stores the uncompressed file data into the zip archive,
             in compliance with the zip spec.  This is an optimization where smaller size is
             preferred over longer run times.
             </para>
            
             <para>
             Next, the library exposes this callback.  With
             this callback, the application can supply its own logic for determining whether
             to apply the Deflate algorithm or not.  For example, an application may desire
             that files over 40mb in size are never compressed, or always compressed.  An
             application may desire that the first 7 entries added to an archive are
             compressed, and the remaining ones are not.  The WantCompression callback
             allows the application full control, on an entry-by-entry basis.
             </para>
            
             <para>
             Finally, the application can specify that compression is not even tried, by setting the
             ForceNoCompression flag.  In this case, the compress-and-check-sizes process as
             decribed above, is not done, nor is the callback invoked.
             </para>
             </remarks>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipEntry.UseUtf8Encoding">
            <summary>
            Set to indicate whether to use UTF-8 encoding on filenames and 
            comments, according to the PKWare specification.  
            </summary>
            <remarks>
            If this flag is set, the entry will be marked as encoded with UTF-8, 
            according to the PWare spec, if necessary.  Necessary means, if there are non-ANSI 
            characters in the filename or in the comment attached to the entry.  
            The default is to use IBM437 encoding. 
            </remarks>
            <remarks>
            Setting this flag to true is equivalent to setting <c>Encoding</c> to <c>System.Text.Encoding.GetEncoding("UTF-8")</c>
            </remarks>
        </member>
        <member name="P:Ionic.Utils.Zip.ZipEntry.Encoding">
            <summary>
            The text encoding to use for this ZipEntry.  
            </summary>
            <remarks>
            <para>
            In its AppNote.txt document, PKWare describes how to specify in the zip entry header
            that a filename or comment containing non-ANSI characters is encoded with UTF-8.  But, some 
            archivers do not follow the specification, and instead encode super-ANSI characters using the 
            system default code page.  For example, WinRAR when run on a machine in Shanghai may encode 
            filenames with the Chinese code page.  This behavior is contrary to the Zip specification, but it 
            occurs anyway.
            </para>
            <para>
            When writing zip archives that will be read by one of these other archivers, use this property to 
            specify the code page to use when encoding filenames and comments into the zip file.
            </para>
            <para>
            Be aware that a zip file created after you've explicitly specified the code page will not 
            be compliant to the PKWare specification, and may not be readable by compliant archivers. 
            On the other hand, many archivers are non-compliant and can read zip files created in 
            arbitrary code pages. 
            </para>
            <para>
            When using an arbitrary, non-UTF8 code page for encoding, there is no standard way for the 
            creator (DotNetZip) to specify in the zip file which code page has been used. DotNetZip is not
            able to inspect the zip file and determine the codepage used for the entries within it. Therefore, 
            you, the application author, must determine that.  If you use a codepage which results in filenames
            that are not legal in Windows, you will get exceptions upon extract. Caveat Emptor.
            </para>
            </remarks>
        </member>
    </members>
</doc>
